202210310329
***
[[00 C-шарп]]
***
# часть 1. Основы программирования на С#
## глава 1. ваше первое консольное приложение на C#
### компьютерные языки C# и .NET
#### что такое программа
Программа - в практическом смысле это выполнимый файл, который можно запустить.
Программа состоит из одного или нескольких *исходных файлов*.
Исходный файл C# - текстовый файл содержащий последовательность команд C#, в соответствии с грамматикой C#.

#### что такое C#
C# промежуточный язык программирования, исп. для создания программ.
С# сочетает мощность C++ и простоту Visual Basic.
Файл программы на С# имеет расширение *.cs*

C# имеет ряд свойств:
- *гибкость*
  Программы C# могут выполняться на локальной машине, и быть переданы через интернет и выполнятся на удаленном компьютере.
- *мощь*
  C# имеет тот же набор команд, что и C++, но "со сглаженными острыми углами"
- *простота использования*
  Защита от ошибок C# спасает от большинства ошибок C++, поэтому на отладку программ тратится гораздо меньше времени.
- *визуальная ориентированность*
  Библиотека кода .NET, которую исп. C# предоставляет многофункциональный интерфейс.
- *дружественность к интернету*
  C# имеет ключевую роль в платформе .NET Framework.
- *безопасность*
  Любой язык для исп. в Интернете, должен вкл. серьезные средства защиты от злонамеренных хакеров.

#### что такое .NET
Проект .NET это новый способ программирования. Он даёт простые визуальные инструменты.
*краткая история*
...

#### что такое Visual Studio 2017 и Visual C#
Первый "визуальный" язык от Microsoft был Visual Basic.
Первый популярный язык от Microsoft был Visual C++.
Visual - встроенный графический интерфейс пользователя.

В итоге Microsoft перевела все языки в единую среду - Visual Studio.
...

### создание первого консольного приложения
#### создание исходной программы
*регионы (region)* помогают сосредоточится на коде, над которым работа ведется в данный момент, скрывая код, который на данный момент не нужен.
Можно добавить свои регионы написав `#region` и `#endregion` и указать название региона.
прим.
```
#region название
... ваш код
#endregion название
``` 
```
Название может содержать пробелы.
Можно вкладывать регионы в другие, но перекрывать друг-друга они не могут. 
```
`using System` это пока все что необходимо, все остальное можно удалить.
***
#### тестовая поездка
Чтобы преобразовать текст C# в программу, необходимо перейти в "вид" => "вывод"
```
Сборка начата…
1>------ Сборка начата: проект: ConsoleApp1, Конфигурация: Debug Any CPU ------
========== Сборка: успешно: 1, сбой: 0, в актуальном состоянии: 0, пропущено: 0==========
```
```
если "успешно", значит все хорошо.
```
Чтобы запустить программу "отладка" => "запуск без отладки".

### заставим программу заработать
- отредактируйте код
```
using System;
namespace Program1
{
    public class Program
    {
        //здесь программа начинает работу
        static void Main(string[] args)
        {
            //приглашение пользователя ввести своё имя
            Console.WriteLine("введите ваше имя:");

            //чтение введенного имени
            string name = Console.ReadLine();

            //приветствие пользователя по имени
            Console.WriteLine("Привет, " + name);

            //ожидание реакции пользователя
            Console.WrightLine("Нажмите <Enter> для выхода...");
            Console.Read();
        }
    }
}
```
- нажмите "сборка" => "построить (название программы)"
- запустить программу "отладка" => "запуск без отладки" (появится консоль)
...
***
### обзор консольного приложения
#### каркас программы
Основной каркас всех консольных приложений имеет следующий вид:
```
using System;
using System.Collection.Generic;
using System.Linq;
using System.Text;
namespace Program1
{
	public class Program
	{
		//здесь программа начинает работу
		public static void Main(string[] args)
		{
			//здесь находится ваш код
		}
	}
}
```
Программа начинает выполняться с инструкции после `Main()` в фигурных скобках `{ }`.

Список директив `using` может находится перед фразой `namespace Program1` или после неё.
Порядок директив не имеет значения.
***
#### комментарии
`//` - однострочные
`/* */` - многострочные
***
#### тело программы
Основная программа заключена в пределах `Main() { }`
прим.
```c
static void Main(string[] args)
        {
            //приглашение пользователя ввести своё имя
            Console.WriteLine("введите ваше имя:");

            //чтение введенного имени
            string name = Console.ReadLine();

            //приветствие пользователя по имени
            Console.WriteLine("Привет, " + name);

            //ожидание реакции пользователя
            Console.WrightLine("Нажмите <Enter> для выхода...");
            Console.Read();
        }
```
![[С-шарп для чайников совет 1.png|500]]

`Console.WriteLine` записывает строку символов в консоль.

`string name = Console.ReadLine();` сохраняет ответ пользователя в *переменной* с именем *name*.

`Console.WriteLine("Привет, " + name);` объединяет строку `"Привет, "` с переменной `name` и выводит результат на консоль.

```
//ожидание реакции пользователя
Console.WrightLine("Нажмите <Enter> для выхода...");
Console.Read();
```
`Console.Read();` заставляет компьютер ждать, пока пользователь нажмет *Enter* для продолжения.

Этот шаг важен в зависимости от того, как выполняется программа.
Окно консоли может закрыться так быстро, что вы не успеете прочитать результат.

### введение в хитрости панели элементов
Ключевая часть программы 
```
//ожидание реакции пользователя
Console.WrightLine("Нажмите <Enter> для выхода...");
Console.Read();
```
Есть простой способ повторного создания ключевых строк в каждом консольном приложении.
#### сохранение кода на панели элементов
Надо сохранить строки в удобном месте для использования в будущем: в окне панели элементов.
1. выделите необходимые строки
2. открыть окно "панель элементов" "вид" => "панель элементов"
3. перенесите выделенные строки в "панель элементов"
#### повторное использование кода из панели элементов
2-ой клик ЛКМ на текст в "панели элементов".
## глава 2. работа с переменными
Фундаментальная концепция программирования - переменная.
Переменная - аналог ящика, в котором можно хранить вещи (числа) для последующего применения.

Для программистов C# накладывает ряд ограничений на переменные по опред. причинам.
Для C# они облегчают понимание переменной определенного типа.
Для вас облегчают поиск ошибок в коде.
Мы узнаем как объявлять, инициализировать и использовать переменные, а также некоторые фундаментальные типы данных в C#.
### объявление переменной
прим.
`int n;` - выделим небольшое колич. памяти компьютера и назначим имя `n`
`n = 1;` - сохраним значение `1` в переменной `n` заменив предыдущее значение

**запомни**
*оператор присваивания*
Знак равенства (=)

**технические подробоности**
Математик говорит: "n равно 1".
Программист выражается более точно:
"сохраним значение 1 в переменной n".
Операторы C# указывают компьютеру, что именно нужно сделать.
Оператор - это глагол, а не существительное.
Оператор присваивания берет значение справа и сохраняет в переменной указанной слева.

### что такое int
В C# каждая переменная имеет фиксированный тип.
Например тип "для целых чисел" не получится поместить строку.

В предыдущем прим. мы выбрали тип для работы с целыми числами `int`.

**запомни**
Перед тем как использовать переменную, её нужно *объявить*.
Объявив переменную как `int`, в неё можно помещать целые значения и извлекать их из неё.
прим. 
```
//объявляем переменную n
int n;
//объявляем переменную m и инициализируем значение 2
int m = 2;
//присваиваем значение, хранящееся в m, переменной n
n = m;
```
- 1 строка - *объявление*, создает небольшую область в памяти с именем `n`, предназначенную для хранения целых значений.
Начальное значение `n` не определено, пока не *присвоено* значение.

- 2 объявление объявляет меременную `m` типа `int`, и *инициализирует* её значением 2.

**запомни**
Термин *инициализировать* означает присвоить начальное значение.
Инициализация переменной заключается в первом присваивании ей значения.
Ничего не получится сказать о значении переменной, до тех пор пока она не будет инициализированна.

- последняя инструкция присваивает значение, хранящееся в `m` (2), переменной `n`.
  переменная `n` будет хранить значение 2, пока не будет присвоено новое значение.

#### правила объявления переменных
Можно выполнить инициализацию переменной как часть её объявления:
```
//объявление переменной типа int с присваиванием её начального значения 1
int p = 1;
```
т. е. записать значение переменной сразу при создании.

**совет**
Инициализируйте переменные при их объявлении. Во многих (не во всех) случаях C# инициализирует переменные вместо вас, но расчитывать на это нельзя.
прим. 
C# помещает 0 в неинициализированную переменную `int`, но компилятор будет выводить сообщение об ошибке.

**внимание**
Вы не можете использовать переменную до того, как она будет объявлена и присваивать значения.
```
//это присваивание неверно, поскольку переменной m не присвоено значение перед её использованием
int n;
int m;
n = m;
//это присваивание некорректно в силу того, что переменная p не была объявлена до её использования
p = 2;
int p;
```

Нельзя дважды объявить одну и ту же переменную в одной области видимости (прим. функции).

#### вариации на тему int
Большинство простых переменных имеют тип `int`.
Однако C# позволяет настраивать целый тип для конкретных случаев.

Все целочисленные типы переменных ограничены хранением только целых чисел, но диапазоны этих чисел различны.
прим. 
Переменная `int` может хранить целые числа в диапазоне от -2 до 2 млрд.

2 млрд. см. - это больше диаметра Земли, 
но если этой величины не хватает, C# предоставляет ещё один целочисленный тип, `long`.
Он занимает 8 байт.

В C# есть и другие целочисленные типы.
![[размер и диапазон целочисленных типов C-шарп 2.png|500]]
![[размер и диапазон целочисленных типов C-шарп 1.png|500]]

Целочисленные константы, отличные от `int`, должны явно указывать свой тип.
Например 123U.
U - это константа `uint`, беззнаковое целое.

Большинство целых значений - *знаковые (signed)*
т. е. они могут иметь положительные и отрицательные значения.
Беззнаковые (unsigned) целые числа представляют только неотрицательные значения, но зато удваивается диапазон.

**совет**
В это книге беззнаковые целые нам не понадобятся.

### представление дробных чисел
Для множества вычислений необходимы дробные числа, которые не могут быть представлены целыми числами.
прим. *уравнение преобразования температуры Фаренгейты в Цельсия*
```
//преобразование температуры 41F
int fahr = 41;
int celsius = (fahr - 32)*(5/9);
```
Возьмем значение 100F и при исп. целых числе получаем 37, 
но правильный ответ 37,777... и т. д.

**запомни**
Тип `int` может представлять только целые числа.
Целый эквивалент числа 37,78 - 37.
Для того чтобы разместить число в целой переменной, дробная часть отбрасывается.
Это называется *усечением (truncation)*.

**технические подробности**
*Усечение* - это не *округление (rounding)*.
При усечении отбрасывается дробная часть, а при округлении получается ближайшее целое число.
Усечение 1,9 = 1. Округление 1,9 = 2.

Для множества приложений, "усечение" неприемлимо.

Но всё гораздо хуже.
Тип `int` не в состоянии хранить значение 5/9 и преобразует его в 0.
Соответственно, данная формула будет давать нулевое значение `celsius` для любого значения `fahr`.

### работа с числами с плавающей точкой
Ограничение переменной `int`, для многих приложений неприемлимы.
Главным препятствием является не диапазон возможных значений, а невозможность представления дробных чисел.

В некоторых ситуациях нужны числа, которые могут иметь ненулевую дробную часть *действительные числа (real numbers)*.

**запомни!**
Действительное число *может* иметь ненулевую дробную часть, 
т. е. число 1,5 является действительным так же, как и число 1,0, 
прим. 
1,0+0,1=1,1.
При чтении оставшейся главы не забывайте о наличии запятой
(в C# вместо запятой используется точка).

C# понимает что такое действительные числа.
Они могут быть с плавающей точкой и десятичным представлением.
Гораздо более распространена плавающая точка.

#### объявление переменной с плавающей точкой
Объявление переменной с плавающей точкой
`float f = 1.0;`

После объявления переменной `float`, она останется такой при всех операциях.

В табл. рассматриваются исп. в C# типы с плавающей точкой.
Все переменные данных типов, знаковые.
![[C-шарп переменные с плавающей точкой.png|500]]

**запомни!**
Можно подумать, что `float` - это тип по умолчанию для переменных с плавающей точкой, 
на самом деле по умолчанию исп. `double`.
Если вы не определите явно тип для 12,3
C# сделает его `double`

В "точность цифр" указано количество значащих цифр, которые может представлять переменная.
`float` точность 6 цифр, 5/9=0,5555551457382

Все цифры после шестой пятерки ненадежны.

`double` 5/9=0.55555555555555557823

Тип `double` имеет 15-16 значащих цифр.

**совет**
Числа с плавающей точкой в C# по умолчанию имеют точность `double`.
Применяйте `double`, если у вас нет веских причин поступить иначе.
прим. *уравнение преобразования температуры Фаренгейты в Цельсия с плавающей точкой*
```
double celsius - (fahr - 32.0) * (5.0 / 9.0)
```

#### ограничения переменных с плавающей точкой
##### перечисление
Нельзя исп. числа с плавающей точкой для перечисления. 
Есть вещи которые нужно просто сосчитать.
C# не знает как посчитать дробные числа.

**запомни!**
Вы не можете использовать числа с плавающей точкой для подсчета количества.

##### сравнение чисел
Следует быть осторожным при сравнении чисел с плавающей точкой.
12,6 может быть 12,600001.
Компьютер подобные "добавки" воспринимает буквально.
Для C# 12,600000 и 12,600001 - это разные числа.

Сложив 1,1 и 1,1, вы можете получить 2,2 или 2,200001.
Спросив, "равно ли значение doubleVariable 2,2?", 
вы получите другой ответ.

**технические подробности**
Современные процессоры исп. небольшой трюк, который немного уменьшает данную неприятность:
во время работы они применяют спец. формат, в котором для числа с плавающей точкой выделяется 80 бит
(или даже 128 бит на новых процессорах).
При округлении такого числа до 64 бит почти всегда получается результат, который вы ожидаете.

##### скорость вычеслений
Целые числа всегда быстрее, чем числа с плавающей точкой, т. к. целые числа менее сложные.
Процессоры работают быстрее с целыми числами.

**технические подробности**
Процессоры Intel выполяют целочисленные вычисления с использованием внутренней структуры, именуемой регистрами общего назначения, 
которые могут работать только с целыми числами.
Эти же чрезвычайно быстрые регистры используются для подсчета.
Числа с плавающей точкой требуют спец. области процессора, 
которая может работать с действительными числами, называется арифметическим-логическим устройством, 
и спец. регистров с плавающей точкой, которые не годятся для подсчета.
Такие расчет отнимают больше времени из-за доп. работы, которая треб для чисел с плавающей точкой.

К сожалению, современные процессоры настолько сложные, что невозможно сказать сколько времени будет сэкономлено, используя целые числа.

##### ограниченность диапазона
В прошлом переменные с плавающей точкой могли представить значительно больший диапазон чисел, чем целые.
Сейчас диапазон целых чисел существенно вырос.

**внимание!**
Даже просто тип `float` способен хранить очень большие числа, 
но количество значащих цифр у него ограничено примерно 6-ю.
прим. 
123456789F = 123456000F
(что такое F, узнаете позже).

### десятичные числа: комбинация целых чисел и чисел с плавающей точкой
Целые и десятичные числа имеют свои недостатки. 
Переменные с плавающей точкой имеют проблемы, связанные с вопросом округления из-за недостаточной точности представления, 
а целые переменные не могут представлять числа с дробной частью. 
Необходимы числа, которые:
- могут хранить дроби;
- подобно целым числам, представлять точные результаты вычислений.

В C# этот тип чисел называется `decimal`.
Диапазон от (-1)10^28 до +10^28

#### объявление переменных типа decimal
Переменные типа `decimal` объявляются и используются также, как и переменные других типов.
```
decimal m1 = 100; //хорошо
decimal m2 = 100M; //ещё лучше
```
Объявление `m1` выделяет память для переменной `m1` и инициализирует её значением 100.
Неприятно то что 100 имеет тип `int`.
Поэтому C# конвертирует `int` в `decimal` перед инициализацией.

Лучше использовать объявление переменной `m2` с констанотой `100M` тип `decimal`.
Буква `M` в конце числа указывает, что данная константа имеет тип `decimal`, так что преобразования не требуется.

#### сравнение десятичных и целых чисел, а также чисел с плавающей точкой
У `decimal` есть 2 значительных ограничения:
1. Они имеют дробную часть, они не могут использовать в качестве счетчика, например в циклах.
2. Вычисления с этим типом происходят гораздо медленнее, чем с простыми числами и числами с плавающей точкой.
   В простых тестах `decimal` оказался в 50 раз медленнее работы с числами `int`.
   Это отношение становится ещё хуже для более сложных операции.
   Большинство математических функций, sin или возведение в степень, не имеют версий для работы с `decimal`.

Числа `decimal` больше подходят для финансовых приложений, в которых важна точность, но само количество вычислений невелико.

### логичен ли логический тип
Переменная логического типа `bool` имеет только 2 значения - `true` и `false`.

**внимание!**
Когда то программисты на C и C++ использовали нулевое значение переменной `int` для обозначения `false` и ненулевое для `true`.
В C# так не получится.

Объявление `bool`
```
bool thisABool = true;
```
Не существует способов преобразования `bool` в другой тип переменных.

### символьные типы
Программы должны работать не только с цифрами, но и с буквами.
C# рассматривает отдельные символы `char` и строки символов `string`.

#### тип char
Переменная `char` может хранить 1 символ.
Символьная константа выглядит как симовол, окруженный одинарными кавычками:
`char c = 'a';`
Вы можете хранить символ из любого алфавита.

`char` можно использовать в качестве счетчика, т. е. его можно прим. в циклах.
Символы не вызывают проблем, связанных с округлением.

**внимание!**
Переменные типа `char` не вкл. информацию о шрифтах, в переменной `char` может хранится вполне корректный иероглиф, 
но при выводе без использования соответствующего шрифта вы увидите только мусор.

#### специальные символы
Некоторые символы являются непечатными - они не видны при выводе на экран или принтер.
Например "пробел".
Другие символы не имеют буквенного эквивалента, например "табуляция".
Для указания таких символов C# исп. обратную косую черту
![[С-шарп специальные символы.png|500]]

#### тип string
Переменная `string`
пример:
```
//объявление с отложеной инициализацией
string someString1;
someString1 = "Это строка";

//инициализация при объявлении предпочтительнее
string someString2 = "Эта строка";
```
Константа `string`, называется также *строковым литералом*, представляет собой набор символов, заключенный в двойные кавычки. 
Символы в строке могут включать спец. символы. 
Строка не может быть перенесена на новую строку в исходном тексте на C#, но может содержать символ новой строки.
пример:
```
//неверная запись строки
string someString = "Эта строка
и это строка";

//а вот верно
string someString = "Это строка\nи это строка";
```
При выводе на экран при помощи вызова `Console.WriteLine` вы увидите текст, размещенный в 2-х строках:
```
Это строка
и это строка
```

Строка не является перечислимым типом, типом-значением.
В процессоре не существует встроенного типа строки.
Процессор понимает только числа, но не буквы.
К строкам применим только "оператор сложения", 
который объединяет 2 строки в одну.
пример:
```
string s = "Это предложение." + " И это тоже.";
```
Приведенный код присваивает строке `s` значение:
```
"Это предложение. И это тоже."
```

**внимание!**
Строка без символов, записанная как "" (пара двойных кавычек), является корректной для `string` и называется *пустой строкой*.
Пустая строка отличается от нулевого символа `\0` и от строки, содержащей любое количество пробелов `(" ")`

**совет**
Предпочтительно инициализировать строки значением `String.Empty`, которое означает то же, что и `""`, но его труднее понять не правильно:
```
string mySecretName = String.Empty; //свойство типа String
```

Все остальные типы данных в главе - *типы-значения (value types)*.
Строковый тип (в 3 гл.) типом-значением не является.

### что такое тип-значение
**технические подробности**
Типы переменных, описанные в этой главе, имеют фиксированный размер, кроме `string`.
Переменные типов с постоянным размером всегда занимают одно и тоже количество памяти.
При присваивании `a = b` C# может переместить значение `b` в `a`, не принимая доп. мер, 
необходимых при работе с типами переменного размера.
Эти виды переменных хранятся в спец. месте под названием *стек* как фактические значения.
Не нужно беспокоится о стеке, просто нужно знать, что он существует как местоположение в памяти.
Эта характеристика поясняет, почему данные типы называются *типами-значениями* (value types).

**запомни!**
Типы `int, double, bool` и их "близкие родственники" типо `int` являются встроенными (в процессор) типами.
Встроенные типы переменных и тип `decimal` известны как типы-значения.
Тип `string` не относится ни к кому, т. к. переменная хранится в виде "указателя" на данные, который называется *ссылкой* (reference).
Данные строки хранятся в другом месте.

Типы (в гл. 8) "обобщенность", определяемые программистом как ссылочные типы, не являются "встроенными" и "типами значениями".
Тип `string` является ссылочным, но C# рассматривает его особым образом т. к. широко используется.

### сравнение string и char
Хотя строки состоят из символов, тип `string` существенно отличается от `char`.
Символ заключается в одинарные кавычки. 
Строка в двойные кавычки.
Тип `char` - это всегда один символ.
Данный пример кода не имеет смысла в плане сложения и конкатенации:
```
char c1 = 'a';
char c2 = 'b';
char c3 = c1 + c2
```

**технические подробности**
На самом деле этот код почти компилируем, но его смысл существенно отличается от того, который мы ему приписываем.
Язык C# преобразует `c1` и `c2` в значения типа `int`.
Ошибка возникает при попытке сохранить в `c3`, 
т. к. при размещении значения типа `int` в переменной меньшего размера `char` данные могут быть потеряны.
В любом случае эта операция не имеет смысла.

Строка может быть любой длинны. 
Конкатенация 2-х строк вполне осмысленна:
```
string s1 = "a";
string s2 = "b";
string s3 = s1 + s2; //результат "ab"
```

В качестве части библиотеки C# определяет целый ряд строковых операций, которые будут описаны в гл. 3 "работа со строками".

**совет**
*Соглашение об именовании*
Программирование - сложное дело, чтобы усложнять его ещё больше.
Чтобы код C# было легче читать, используются опред. соглашения об именовании переменных, которым желательно следовать, чтобы код был понятен другим программистам.

- *имена всех объектов, кроме переменных, начинаются с прописной буквы, а имена переменных - со строчной*.
  Делайте эти имена как можно более информативными (зачастую это приводит к тому, что имена состоят из нескольких слов).
  Слова для объектов, не являющихся переменными, должны начинаться с прописной буквы, и лучше, если между ними не будет символов подчеркивания, прим. `ThisIsALongName`.
- *имена переменных отличаются только тем, что первая буква - строчная: thisIsALongVariableName*.

До эры .NET исп. соглашение, в соответствии с которым первая буква имени переменной указывала её тип ("венгерская запись").
Большинство таких букв тривиальны:
f - float
d - double
s - string
и т. д.
Исключением является n - int.
Есть ещё одно исключение,
по традиции программирования буквы i, j, k также исп. как распространенные имена переменных int.

### вычисление високосных лет: DateTime
Если нужна программа для выяснения, является ли некоторый год високосным. 
Алгоритм поставленной задачи:
```
Год високосный, если он делится на 4,
но если при этом он делится на 100, то он високосный, только если делится на 400.
```
Пока что вы не знаете, как перевести это в C#. 
Но можно просто спросить `DateTime` о том, високосный ли некоторый год
(тип `DateTime` является типом-значением наподобие `int`)
```
DateTime thisYear = new DateTime (2011, 1, 1);
bool isLeapYear = DateTime.IsLeapYear (thisYear.Year);
```
Результат для 2016 года - `true`, для 2017 - `false`.

Тип `DateTime` позволяет выполнить ~80 разных операций, 
например получение названия месяца и дня недели;
добавление дней, часов, минут и т. д. к конкретной дате;
получение количества дней в месяце;
вычитание 2-х дат.

прим.
Свойство `Now` типа `DateTime` исп. для установки текущего времени и даты, 
а один их множества методов `DateTime` исп. для преобразования одного времени в другое:
```
DateTime thisMoment = DateTime.Now;
DateTime anHourFromNow = thisMoment.AddHourse(1);
```
Можно выделить определенный части типа `DateTime`
```
int year = DateTime.Now.Year; //например, 2008
DayOfWeek dayOfWeek = 
	DateTime.Now.DayOfWeek; //например воскресенье
```
Можно выполнить множество других манипуляций типом
```
DateTime:
DateTime date = DateTime.Today; //получение даты
TimeSpan time = thisMoment.TimeOfDay //получение времени
TimeSpan duration =
	new TimeSpan(3, 0, 0, 0); //продолжительность в днях
DateTime threeDaysFromNow = thisMoment.Add(duration);
```

Первые 2 строки выделяют нужную информацию из `DateTime`.
След. 2 - добавляют *продолжительность* к `DateTime`.
Продолжительность, или количество времени, отличается от момента времени;
указывается с помощью класса `TimeSpan`, а момент времени - при помощи `DateTime`.
3 строка устанавливает продолжительность `TimeSpan` равной 3 дням, 0 часов, 0 мин, 0 сек.
4 строка добавляет эту продолжительность к объекту `DateTime`, 
представляющий текущий момент времени, 
и даст новый объект `DateTime`, представляющий время через 3 дня после текущего.

Вычитание `TimeSpan` из `DateTime` и прибавление его к `DateTime` дает `DateTime`:
```
TimeSpan duration1 = new TimeSpan(1, 0, 0); //один час
//если Today даёт 00:00:00, то приведенный код даст 01:00:00

DateTime midnight = 
	anHourAfterMidnight.Subtract(duration1);
Console.WriteLine("За час до 01:00 - {0}", midnight);
```
Первая строка создает продолжительность в 1 час,
вторая получает время и добавляет 1 час.
В последующих строках этот час вновь вычитается.








***
Объявление числовых констант
Преобразование типов
Позвольте компилятору C# вывести типы данных

51+20=71 стр.
64 - 591
591-64=527/29=18 стр/дн
закладка 64 стр.
след. день 64+18=82 стр.
### объявление числовых констант
*объявление констант с их типов*
![[C-шарп объявление констант с их типом.png|500]]
### преобразование типов
прим. преобразование `int` => `long`:
```
int intValue = 10;
long longValue;
longValue = intValue; //это присваивание корректно
```
Переменная типа `int` может быть преобразована в `long`, т. к. любое значение `int` может хранится в `long`.
C# выполяет это преобразование автоматически.
Такое преобразование типов называется *неявным* (implicit).

Преобразования в обратном направлении могут вызвать проблемы.
прим. с ошибкой:
```
long longValue = 10;
int intValue;
intValue = longValue; // Неверно!
```

**совет**
Некоторые значения, которые могут хранится в переменной `long`, не помещаются в переменной типа `int` (прим. 4 млрд).
C# генерирует сообщение об ошибке, т. к. в процессе преобразования данные могут быть утеряны.
Ошибку такого рода сложно обнаружить.

Если вы знаете что такое преобразование допустимо?
прим. 
Несмотря на то что переменная `longValue` имеет тип `long`, в данной конкретной программе её значение не может превышать 100.
В этом случае преобразование `longValue` типа `long` в переменную `intValue` типа `int` корректно.

Можно объяснить C#, что вы отлично понимаете, что делаете, используя *приведение типов*:
```
long longValue = 10;
int intValue;
intValue = (int)longValue; //все в порядке
```
При проведении вы размещаете имя треб. типа в круглых скобках перед преобразуемым значением.

`int` и `long` автоматически могут быть преобразованы в числа с плавающей точкой, 
но для обратного преобразования необходим оператор приведения типов:
```
double doubleValue = 10.0;
long longValue = (long)doubleValue;
```

Все приведения к типу `decimal` и из него нуждаются в операторе приведения типов.
В действительности все числовые типы могут быть преобразованы в другие числовые типы с помощью такого оператора, 
кроме `bool` и `string`.

**технические подробности**
Встроенные методы C# могут преобразовывать числа, символы или логические переменные в их строковые "эквиваленты".
Например вы можете преобразовать значение `true` типа `bool` в строку `true`;
Однако такое преобразование нельзя рассматривать как непосредственное.
Эти 2 значения - совершенно разные вещи.

### позвольте компилятору C# вывести типы данных
В главах выше объявляя переменную, мы *всегда* указывали её точный тип:
```
int i = 5;
string s = "Hello C#";
double d = 1.0;
```
Но можно переложить часть работы на компилятор C#, воспользовавшись `var`:
```
var i = 5;
var s = "Hello C#";
var d = 1.0;
```
В этом случае компилятор сам *выводит* тип данных - он смотрит на то, что находится в правой части присваивания, 
чтобы выяснить, какой тип требуется в левой части.

**технические подробности**
В главе 3 "работа со строками", рассматривается, как вычисляется тип выражений приведенных выше.
Но эта информация скорее всего не понадобится - компилятор справится самостоятельно.
Предположим, что вы инициализируете выражение `var x = 3.0 + 2 - 1.5;`

Компилятор в состоянии вывести, что `x` - значение типа `double`. 
Он видит 3.0 и 1.5 и знает что это тип `double`.
Затем он видит что 2 имеет тип `int`, который компилятор может *неявно* конвертировать в `double` для выполнения вычислений.
В результате все члены выражения `x` имеют тип `double`.

Для объявления переменной достаточно `var` и инициализирующего выражения, 
остальное компилятор сделает сам:
```
var aVariable = <выражение инициализации>;
```

**технические подробности**
Если вы работали с JavaScript или VBScript, то вы должны исп. типы данный "всё в одном".
В VBScript тип данных называется `Variant` - тип данных, который может быть чем угодно.
Является ли `var` в C# обзначением типа данных `variant`? Нет.
Объект, объявленный `var` *имеет определенный тип данных* C#, такой как `int`, `string`, `double`.
Вы просто объявляете его.

Чем на самом деле являются переменные `var`?
```
var aString = "Hello C#";
Console.WriteLine(aString.GetType().ToString());
```
Инструкция `WriteLine` вызывает метод `String.GetType()` объекта `aString`, чтобы получить его тип данных C#.
После для получения объекта вызывается метод `ToString()`, позволяющий вывести название типа.
В консоли будет ответ `System.String`.
Значит тип переменно `aString`.

**совет**
В большинстве случаев не стоит использовать `var`.
Оставте его на те случаи, когда это необходимо.
Явное указание типа переменной делает исходный текст понятнее для тех, кто его будет читать.

**совет**
Вы можете встретить различные применения `var`, например с массивами или коллекциями данных (гл. 6 "Глава для коллекционеров") или с анонимными типами (часть 2 "Объектно-ориентированное программирование на C#").

Начиная с C#4.0 типы становятся более гибкими, чем `var`.
Например тип `dynamic`.
## глава 3. работа со строками
Во многих приложениях тип `string` можно рассматривать как один из встроенных типов-значений вроде `int` или `char`.
К строкам применимым некоторые из операций,
прим.
```
int i = 1; //объявление и инициализация int
string s = "abc"; //объявление и инициализация string
```
В других отношениях, строки можно рассматривать как пользовательский класс
```
string s1 = new String();
string s2 = "abcd";
int lengthOfString = s2.Length;
```
`String` - это класс, т. к. он очень сильно распространён, C# трактует его спец. образом.
Например, ключевое слово `string` является синонимом имени класса `String`.
прим.
```
String s1 = "abcd"; //присваивание строкового литерала объекту класса String
string s2 = s1; //присваивание объекта класса String строковой переменной
```
В этом примере переменная `s1` объявлена как класс `String`, 
`s2` объявлена просто как `string`.
Эти 2 присваивания демонстрируют, что `string` и `String` - это одинаковые (или совместимые) типы.

**технические подробности**
В действительности то же самое справедливо и для других встроенных типов.
Даже тип `int` имеет соотвествующий класс `Int32`.
`Double` - класс `Double` и т. д.
Отличие в том, что `string` и `String` - это одно и тоже.

### неизменяемость строк
После того как объект `string` создаен, его нельзя изменить.
В C# нет операции, модифицирующей реальный объект `string`.
Внешне может показаться, что множество операторов модифицируют объекты `string`, 
но это не так - они всегда возвращают модифицированную строку как новый объект `string`.

прим. 
Операция `"Его имя - "`+`"Randy"` не изменяет ни одну из строк, а генерирует новую строку `"Его имя - Randy"`.
Побочный эффект такого поведения является то, что вы не должны беспокоиться, что кто-то изменит строку без вашего ведома.

прим.
```
// ModifyString - методы класса String не модифицируют сам объект 
// (s.ToUpper() не изменяет строку s; вместо этого он возвращает новую преобразованную строку)
using System;

namespace ModifyString
{
	class Program
	{
		public static void Main(string[] args)
		{
			//создание объекта Student
			Student s1 = new Student();
			s1.Name = "Jenny";

			//создаем новый объект с тем же именем
			Student s2 = new Student();
			s2.Name = s1.Name;
			
			//"Изменение" имени объекта s1 не изменяет сам объект,
			//поскольку ToUpper() возвращает новую строку, 
			//не влияя на оригинал
			s2.Name = s1.Name.ToUpper();
			Console.WriteLine("s1 - " + s1.Name + ", s2 - " + s2. Name);
			
			//ожидаем подтверждения пользователя
			Console.WriteLine("Нажмите <Enter> для " + "завершения программы...");
			Console.Read();
		}
	}
	//Student - простейший класс, содержащий строку class Student
	{
		public String Name;
	}
}

```
Что такое классы, будет в 2 части "Объектно-ориентированное программирование на C#".
Класс `Student` содержит переменную `Name` типа `String`.
Объекты класса `Student s1` и `s2` созданы так, что их члены `name` указывают на одни и те же строковые данные.
Вызов метода `ToUpper()` преобразует строку `s1.Name`, изменяя все её символы на прописные.
Никаких проблем, связанных с тем, что `s1` и `s2` указывают на 1 объект, не возникает, 
т. к. метод `ToUpper()` не изм. `Name`, а создает новую строку, записанную прописными буквами.

Вот что выводит на экран программа:
```
s1 - Jenny, s2 - JENNY
Нажмите <Enter> для завершения программы...
```

Это свойство строк называется *неизменностью*.

**технические подробности**
Неизменность строк очень важна для строковых констант.
Строка `Эта строка` представляет собой вид строковой константы, как `1` представляет константу `int`.
Компилятор может заменить все обращения к одинаковым константным строкам обращением к одной константной строке, 
что снижает размер полученной программы.
Такое поведение было бы невозможным, если бы строки могли изменяться.

### основыне операции над строками
Программисты C# очень часто выполняют операции над строками.
В каждой программе есть "сложение" строк
прим.
```
string name = "Randy";
Console.WriteLine("Его имя - " + //+ означает кокатенацию name);
```
Этот спец. оператор обеспечивается классом `String`. 
Однако класс `String` предоставляет др. методы работы со строками.
- сравнение строк на равенство или в алфавитном порядке
- изм. и преобразование строк: замена частей, регистра символов, преобразования между строками и иными типами
- обращение к отдельным символам строки
- поиск символов или подстрок в строке
- обработка информации из командной строки
- форматирование вывода
- работа с исп. `StringBuilder`

### сравнение строк
Часто треб. сравнение 2-х строк.
прим. 
- ввел ли пользователь ожидаемое значение?
- есть список строк, которые нужно отсортировать в алфавитном порядке

Практики призывает избегать стандартных операторов сравнения = = и ! =,
исп. встроенные функции сравнения.
Могут быть различные нюансы при их работе, 
эти операторы не всегда работают так, как ожидалось.
Кроме этого применение функций сравнения делает код яснее и легче в поддержке.

#### проверка равенства: метод Compare()
Множество операций рассматривает строку как единый объект, 
например метод Compare(), который сравнивает 2 строки, вводя отношение "меньше-больше".
- если левая строка *больше* правой, Compare(left,right) возвращает 1.
- если левая строка *меньше* правой, Compare(left,right) возвращает -1.
- если строки равны, Compare(left,right) возвращает 0

прим. 
Алгоритм работы `Compare()`, записанный с использование *псевдокода*:
```
compare(string s1, string s2)
{
	//циклический проход по всем символам строк,
	//пока один из символов одной строки не окажется больше соответсвующего ему символа второй строки
	foreach (для каждого) символа более короткой строки
		if (числовое значение символа строки s1 > числового значения символа строки s2)
			return 1
		if (числовое значение символа строки s1 < числового значения символа строки s2)
			return -1
	//если все символы совпали, но строка s1 длиннее строки s2, то она считается больше строки s2
	if в строке s1 остались символы
		return 1
	//если все символы совпали, но строка s2 длиннее строки s1, то она считается больше строки s1
	if в строке s2 остались символы
		return -1
	//если все символы строк попарно одинаковы и строки имеют одну и ту же длинну, то это одинаковые строки
	return 0
}
```
Таким образом, "abcd" больше "abbd", а "abcde" больше "abcd".
В основном в реальных ситуациях важно не то, какая из строк больше, 
а равна ли 2 строки.
Какая строка больше/меньше - важно в случае сортировки строк.

**запомни**
Метод `Compare()` возвращает значение 0, если 2 строки идентичны. 
В след. тестовой программе это значение исп. для выполнения ряда операций, 
когда программа встречает некоторую строку или строки. 
`BuildASentence` запрашивает у пользователя ввод строк текста.
Эти строки объединяются с предыдущими для построения единого предложения.
Программа завершает работу, если пользователь вводит слово `EXIT, exit, QUIT, quit`.
```
//BuildASentence - данная программа конструирует предложение путем конкатенации пользовательского ввода до тех пор, 
//пока пользователь не введет команду завершения.
//Эта программа демонстрирует использование проверки равенства строк
using System;
namespace BuildASentence
{
	public class Program
	{
		public static void Main(string[] args)
		{
			Console.WriteLine("Каждая введеная вами строка будет добавлятся в предложение, пока вы не введете EXIT или QUIT");
			//Запрашиваем пользовательский ввод и соединяем вводимые пользователем фразы в единое целое, 
			//пока не будет введена команда завершения работы
			string sentence = "";
			for(;;)
			{
				//получение очередной строки
				Console.WriteLine("Введите строку");
				string line = Console.ReadLine();
				//выход при вводе команды завершения
				
				string[] terms = { "EXIT", "exit", "QUIT", "quit" };
				//сравниваем введенную строку с командами выхода
				bool quitting = false;
				foreach (string term in terms)
				{
					//прекращение цикла при совпадении
					if (String.Compare(line, term) = 0)
					{
						quitting = true;
					}
				}
				if (quitting = true)
				{
					break;
				}
				
				//в противном случае добавление введеного к строке 
				sentence = String.Concat(sentence, line);
				//обратная связь
				Console.WriteLine("\nВы ввели: " + sentence);
			}
		Console.WriteLine("\nПолучилось:\n" + sentence);
		//ожидаем подтверждение пользователя
		Console.WriteLine("Нажмите <Enter> для " + "завершения программы...");
		Console.Read();
		}
	}
}
```
После краткого описания своих действий программа созд. пустую строку для предложения, `sentence`, 
после чего входит в "бесконечный" цикл.

**запомни!**
Конструкции `while(true)` и `for(;;)` представляют собой бесконечные циклы, 
выход из которых осуществляется с пом. оператора `break` (выход из цикла) или `return` (выход их программы).
Эти 2 цикла эквивалентны.

Далее программа предлагает пользователю ввести строку текста, которую затем считывает исп. метод `ReadLine()`.
После прочтения строки программа проверяет, не явл. ли введенная строка командой завершения работы.

Раздел завершения программы опред. массив строк `terms` и переменная типа `bool` с именем `quiting`, получающую при инициализации значение `false`.
Каждый элемент в массиве `terms` представляет собой одну их искомых строк.
Все эти строки приводят к завершению программы.

**внимание!**
В массив вкл. строка `EXIT` и `exit`, 
т. к. функция `Compare()` по умолчанию рассматривает их как различные.

Раздел завершения программы циклически просматривает все элементы массива команд завершения работы и сравнивает их с переданной строкой.
Если функция `Compare()` сообщает о соответствии строки, переменная `quiting` получает значение `true`;
Если до завершения цикла соответствие не найдено, то после выхода из цикла она равна `false`.
Программа продолжает работу, добавляя введенную строку в конец предложения с пом. `String.Concat()`.
Программа выводит полученный результат и продолжает работу.

Итерации по массиву - отличный способ проверки на равенство одному из возм. значений.

Вывод программы `BuildASentence`.
```
Каждая введенная вами строка будет добавлятся в предложение, 
пока вы не введете EXIT или QUIT
Введите строку
Программирование на C#

Вы ввели: Программирование на C#
Введите строку
- сплошное удовольствие

Вы ввели: Программирование на C# - сплошное удовольствие
Введите строку
EXIT

Получилось:
Программирование на C# - сплошное удовольствие
Нажмите <Enter> для завершения программы...
```

#### сравнение без учета регистра
Метода `Compare()`, исп. в предыдущем прим., рассматривает строки `"EXIT"` и `"exit"` как различные. 
Но есть вторая версия функции `Compare()`, которой передаются 3 аргумента.
3-ий аргумент этой функции указывает, 
следует ли при сравнении игнорировать регистр букв (значение `true`) или нет (значение `false`)

След. версия раздела завершения программы возвращает значение `true`:
```
//Проверяет, равна ли переданная строка строкам exit или quit,
//независимо от регистра исп. букв
if (String.Compare("exit", source, true) == 0) ||
(String.Compare("quit", source, true) == 0)
{
	quitting = true;
}
```

### изменение регистра
Иногда нужно перевести все символы строки в другой регистр.

#### отличие строк в разных регистрах
Можно использовать конструкцию `switch` для поиска действий конкретной строки.
Конструкция `switch` прим. для сравнения значения переменной с некоторым набором возм. значений, 
эту конструкцию можно прим. для объектов `string`.
прим. раздел завершения с исп. конструкции `switch`:
```
switch(line)
{
	case "EXIT":
	case "exit":
	case "QUIT":
	case "quit":
		return true;
}
return false;
```
Этот подход работает т. к. выполняется сравнение только предопределенного количества строк. 
Цикл `for()` представляет более гибкий подход, а прим. функции `Compare()`, нечувствительной к регистру, 
повышает возм. программы по "пониманию" введенного пользователем.

#### преобразование символов строки в символы верхнего или нижнего регистра
Чтобы преобразовать строку в верхнем регистре в строку в нижнем регистре, исп. метод `ToLower()`.
Если нужно перевести только одну первую букву строки:
```
string name = "chuck";
string properName =
	char.ToUpper(name[0]).ToString() + 
	name.Substring(1, name.Length - 1)
```
Решение - выделить первый символ из строки `name` (т. е. `name[0]`), преобразовать в односимвольную строку с пом. метода `ToString()`, затем прибавить часть строки `name`, 
оставшуюся после удаления первого символа вызовом `Substring()`

Выяснить, находится ли строка в верхнем или нижнем регистре, можно с пом. конструкции `if`:
```
if (string.Compare(line.ToUpper(CultureInfo.InvariantCulture), line, false) == 0) ...
// истинно, если строка в верхнем регистре
```
Здесь метода `Compare()` сравнивает вер. строки `line` в верхнем регистре с исходной строкой `line`.
Если строка изначально в верхнем регистре, строки должны совпадать.

### Цикл по строке

Можно обратится к отдельным символам строки в цикле `foreach`.
Пример кода проходит по символам строки и выводит каждый из них в консоль, 
т. е. выводит строку иным способом:
```
string favoriteFood = "сheeseburgers";
foreach(char c in favoriteFood)
{
	Console.Write(c); //вывод символа
}
Console.WriteLine();
```
Циклом можно воспользоваться для выяснения, 
находится ли вся строка в верхнем регистре:
```
bool isUppercase = true;
//предполагаем, что строка в верхнем регистре
foreach(char c in favoriteFood)
{
	if(!char.IsUpper(c))
	{
		isUppercase = false;
		break;
		//предположение опровергнуто, можно выходить
	}
}
```
В конце цикла переменная `isUppercase` принимает значение либо `true`, либо `false`.
Обращаться к отдельным символам строки можно с исп. записи индекса массива.

**запомни!**
Массивы в C# начинаются с нулевого элемента, 
если вам нужен первый символ, запрашивайте индекс `[0]`.
Если нужен третий символ, запрашивайте индекс `[2]`.
```
char thirdChar = 
	favoriteFood[2]; //первое `е` в "cheeseburgers" 
```

### поиск в строках
Если необходимой найти в строке опред. слово или символ.

#### как искать
Метод `IndexOf();`
```
int indexOfLetterS = favoriteFood.IndexOf('s'); //4
```
Класс `String` имеет др. методы поиска:
- метод `IndexOfAny()` получает массив символов и ищет в строке любой из них, возвращая индекс первого найденного символа
  ```
  char[] charsToLookFor = { 'a', 'b', 'c'};
  int indexOfFirstFound = favoriteFood.IndexOfAny(charsToLookFor); //0
  ```
  этот вызов можно записать в сокращенном виде:
  ```
  int index = name.IndexOfAny(new char[] { 'a', 'b', 'c'});
  ```
- метод `LastIndexOf()` находит не первый встреченный символ, а последний.
- метод `LastIndexOfAny()` работает подобно методу `IndexOfAny()`, но начинает работу с конца строки.
- метод `Contains()` возвращает `true`, если данная подстрока входит в состав строки:
  `if(favoriteFood.Contains("ee") ... //true`
- метод `Substring()` возвращает подстроку, если это возм., или пустую строку в противном случае:
  `string sub = favoriteFood.Substring(6, favoriteFood.Length - 6;`

#### пуста ли строка
Как выяснить, является ли пустой целевая строка (" ") или имеет значение `null` (т. е. не присвоено никакое значение).
Можно исп. метод `IsNullOrEmpty()`
`bool notThere = string.IsNullOrEmpty(favoriteFood); //false`

Обратите внимание на то, как вызывается метод `IsNullOrEmpty()`
`string.IsNullOrEmpty(s)`.

2 способа сделать строку пустой:
`string name = "";`
`string name = string.Empty;`

### получение введенной пользователем информации
Распространненная подзадача в консольных приложениях явл. получение введенной пользователем информации.
Считывать информацию необходимо как строку
(всё что поступает от пользователя, поступает в виде строки).
Затем часто треб. *проанализировать*, или *разобрать* (parse), входную строку, 
наприм. чтобы выделить числовые данные.

#### удаление пробельных символов
Как убрать пробельные символы с обоих концов строки
*пробельный символ* (white space) символы, не отображаемые на экране,
прим. пробел, символ новой строки `(\n)`, табуляция `(\t)`, символ возврата каретки `(\r)`.
Можно исп. метод `Trim():`
```
//удаляем пробельные символы с концов строки
random = random.Trim();
```
Есть методы `TrimFront()` и `TrimEnd()` для удаления пробельных символов с одной стороны строки,
можно передать им массивы символов, которые также должны рассматриваться как пробельные.

Например:
можно убрать расположенный перед денежными значениями символ `$`, 
отчистка строк сделает их анализ более простым.
Все перечисленные методы возвращают новые строки.

#### анализ числового ввода
Программа может считывать с клавиатру по одному символу за раз, 
но в таком случае вам придется самостоятельно обрабатывать ввод символа новой строки и т. п.
Более простой подход, считать строку полностью и разобрать её на отдельные символы.
Посимвольный анализ иногда необходим, но некоторые программисты этим злоупотребляют.

Метод `ReadLine()` исп. для считывания объекта типа `string`.
Программа, которая ожидает числовой ввод, должна преобразовать строку в числа.
C# имеет класс `Convert` со всем необходимыми инструментами, 
наприм. методами преобразования строки в каждый из встроенных числовых типов.

прим. считывание числа с клавиатуры и сохр. в переменной `int`:
```
string s = Console.ReadLine(); //данные вводятся как строка
int n = Convert.ToInt32(s); //и преобразуются в число
```

**запомни!**
Другие методы преобразования ещё более очевидны:
`ToDouble()`, `ToFloat()`, `ToBoolean()`.
Метод `ToInt32()` вып. преобразование в 32-битовое знаковое целое число
(32 бит - это размер `int`), эта функция выполняет преобразование строки в число `int`;
для преобразования строки в число `long` исп. функция `ToInt64()`.

Метод `Convert()`, встретив "неправильный" символ, может выдать некорректный результат.
След. убедится, что строка содержит именно нужные данные.

прим. след. функции возвращает значение `true`, если переданная строка состоит только из цифр.
Такая функция может быть вызвана перед функцией преобразования строки в целое число.
```
//IsAllDigits - возвр. true, если все символы строки явл. цифрами
public static bool IsAllDigits(string raw)
{
	//убираем лишнее с концов строки.
	//Если при этом в строке ничего не остается, 
	//значит строка не представляет собой число
	string s = raw.Trim(); //игнорируем пробельные символы
	if (s.Length == 0)
	{
		return false;
	}
	//циклически проходим по всем символам строки
	for(int index = 0; index < s.Length; index++)
	{
		//наличие в строке символа, не явл. цифрой, 
		//говорит о том, что это не число
		if (Char.IsDigit(sЗ[index]) = false)
		{
			return false;
		}
	}
	//все в порядке: строка состоит только из цифр
	return true;
}
```
**запомни!**
Для чисел с плавающей точкой в строке может указываться точка;
Кроме того, перед числом может находится минус.

Метод `IsAllDigits` сначала удаляет все ненужные пробельные символы.
Если после этого строка оказывается пустой, значит она сост. из пробельных символов и не явл. числом.
Если строка не пустая, функция проходит по всем символам.
Если один из символов не явл. цифрой, функция возвр. `false`, указывает что переданная строка не явл. числом.
Возврат функцией значение `true` означает, что все символы цифры.
След. программа считывает число и выводит на экран.

```
//IsAllSigits - демонстрационная программа,
//иллюстрирующая прим. функции IsAllDigits
using System;

namespace IsAllDigits
{
	class Program
	{
		public static void Main(string[] args)
		{
			//ввод строки с клавиатуры
			Console.WriteLine("введите целое число");
			string s = Console.ReadLine();
			
			//проверка, может ли эта строка быть числом
			if (!IsAllDigits(s))
			{
				Console.WriteLine("Это не число!");
			}
			else
			{
				//преобразование строки в целое число
				int n = Int32.Parse(s);
				//выводим число, умноженое на 2
				Console.WriteLine("2 * {0} = {1}", n, 2 * n);
			}
			//ожидаем подтверждение пользователя
			Console.WriteLine("Нажмите <Enter> для " + "завершения программы...");
			Console.Read();
		}
		//IsAllDigits - возвращает true, если все символы строки явл. цифрами
		public static bool IsAllDigits(string raw)
		{
			//тело функции было рассмотрено ранее и здесь оно для краткости опущено
		}
	}
}
```
Программа считывает строку, вводимую пользователем, и проверяет с пом. функции `IsAllDigits`.
Если функция возвращает `false`, программа выводит предупреждение.
В др. случае программа преобразует строку в число с пом. функции `Int32.Parse()`, 
которая явл. альтернативой `Convert.ToInt32()`.
Программа выводит полученное число и удвоенное значение (это должно доказать корректность преобразования строки в число).

```
Введите целое число
1А3
Это не число!
Нажмите <Enter> для завершения программы...
```

**технические подробности**
Можно попытаться исп. функцию `Convert()` для преобразования строки в число и обработать исключения, генерируемые функцией преобразования. Однако скорее всего функция не сгенерирует исключения, а вернет некорректный результат;
В прим. выше при вводе 1А3 вернется значение 1.
Вы должны проверять вводимые данные самостоятельно.

**совет**
Можно восп. методом `Int32.TryParse(s,n)`, который возвращает `false`, если анализ вып. неудачно, и `true`, если все в порядке.
Этот метод преобразует найденное число в переменную `int`.
Данная функция не генерирует исключений, прим. исп. в след. разделе.

#### обработка последовательности чисел
Часто программы получают в вводимых данных строку сост. из неск. чисел.
Исп. метод `String.Split()`, можно разбить строку на неск. подстрок, 
по одной для каждого числа, и работать по отдельности.

Функция `Split()` преобразует единую строку в массив строк меньшего размера с прим. указанного символа-разделителя.
прим. 
Если сказать фнукции `Split()`, что след. исп. в качестве разделителя запятую, 
строка "1, 2, 3" превратиться в три строки "1", "2", "3".
(*символьным разделителем* может быть любой символ, исп. для разделения элем. коллекций).

прим. программы метод `Split()` применяется для ввода последовательности чисел для суммирования:
```
//ParseSequenceWithSplit - считывает последовательность разделенных запятыми чисел, 
//разделяет её на отдельные целые числа и суммирует их
namespace ParseSequenceWithSplit
{
	using System;
	
	class Program
	{
		public static void Main(string[] args)
		{
			//приглашение пользователю ввести последовательность целых чисел
			Console.WriteLine("введите последовательность целых чисел, разделенных запятыми:");
			
			//считываение строки текста
			string input = Console.ReadLine();
			Console.WriteLine();
			
			//преобразуем строку в отдельные подстроки с исп. в качестве симв. разделителей запятые и пробелы
			char[] dividers = {',', ' '};
			string[] segments = input.Split(dividers);
			
			//конверитуем каждую подстроку в число
			int sum = 0;
			foreach(string s in segments)
			{
				//(пропускаем пустые строки)
				if (s.Length > 0)
				{
					//пропускаем строки, не явл. числами
					if (IsAllDigits(s))
					{
						//преобразуем строку в 32-битное целое число
						int num = 0;
						if (Int32.TryParse(s, out num))
						{
							Console.WriteLine("Очередное число = {0}", num);
							//доб. полученное число в сумму
							sum += num;
						}
						//в случ. ошибки переходим к след. числу
					}
				}
			}
			//вывод суммы
			Console.WriteLine("Сумма = {0}", sum);
			
			//ожидаем подтверждение пользователя
			Console.WriteLine("Нажмите <Enter> для завершения программы...");
			Console.Read();
		}
		//здесь находится тело метода IsAllDigits
	}
}
```

Программа `ParseSequenceWithSplit` начинает работу со считывания строки с клавиатуры.
После методу `Split()` передается массив символов `dividers`, представляющих собой символы-разделители, исп. при отделении отдельных чисел в строке.

Далее программа циклически проходит по всем "подмассивам", созд. функцией `Split()`, прим. цикл `foreach`.
Программа пропускает все подстроки нулевой длинны, 
для непустых строк вызывает функцию `IsAllDigits()`, чтобы проверить что строка явл. числом.
Корректные строки преобразуются в целые числа и суммируются с пом. `sum`.
Неккоректные числа игнорируются (лучше выводить сообщение об ошибке).
Как выглядит вывод программы:

```
Введите последовательность целых чисел, разделенных запятыми:
1, 2, a, 3, 4
Очередное число = 1
Очередное число = 2
Очередное число = 3
Очередное число = 4
Сумма = 10
Нажмите <Enter> для завершения программы...
```

Программа проходит по списку, рассматривая запятые и пробелы как разделительные символы.
Она пропускает "число" `a` и выводит общ. сумму.
В реальных программах, вряд ли можно просто игнорировать некорректные числа, никак не сообщая об этом пользователю.

#### объединение массива строк в одну
Класс `String` имеет метод `Join()`. 
Если у вас есть массив строк, можно исп. `Join()` для конкатенации всех строк.
Можно указать, что между строками в массиве след. вставить опред. символы:

```
string[] brothers = { "Chuck", "Bob", "Steve", "Mike" };
string theBrothers = string.Join(":", brothers);
```

В результате получ. строка `theBrothers`, которая представляет собой `"Chuck:Bob:Steve:Mike"`.
Можно в качестве разделителя исп. др. символ: запятую, табуляцию, пробел.

### управление выводом программы
Вывод программы - это то что видим пользователь.
Важна корректность и внешнее представление выводимых данных.

Класс `String` представляет программисту ряд методов для форматирования выводимой строки. 
Далее будут рассмотрены методы `Trim(), Pad(), PadRight(), PadLeft(), Substring(), Concat()`.

#### исп. методов Trim() и Pad()
Из раздела "Удаление пробельных символов", 
мы узнали как пользоваться методом `Trim()` и спец. вариантом `TrimFront()` и `TrimEnd()`. 
В данном разделе обсуждает др. распространненный метод форматирования выходных данных.
Можно исп. метод `Pad`, которые доб. символы к концам строки, 
чтобы расширить строку до опред. длинны.
Добавить пробелы слева или справа, чтобы выровнять содержимое;
Можно доб. символы `"*"` и т. д.

Программа `AlignOutput` исп. `Trim()` и `Pad()` для обрезки и выравнивания ряда имен

```
using System;
using System.Collections.Generic;
//AlignOutput - выравнивание множества строк для улучшения внешнего вида программы
namespace AlignOutput
{
	class Program
	{
		public static void Main(string[] args)
		{
			List<string> names = new List<string> {"Christa ", " Sarah", "Jonathan", "Sam", " Schmekowitz"};
		}
		//выводим имена
		Console.WriteLine("Следующие имена имеют разные длины:");
		
		foreach (string s in names)
		{
			Console.WriteLine("Имя '" + s + "' до обработки");
		}
		Console.WriteLine();
		//делаем строки выровненными влево, одинаковой длинны
		//сначала копируем исходный массив
		List<string> stringToAlign = new List<string>();
		
		//удаляем лишние пробелы с обоих концов
		for (int i = 0; i < names.Count; i++>)
		{
			string trimmedName = names[i].Trim();
			stringsToAlign.Add(trimmedName);
		}
		//находим длинну самой длинной строки
		int maхLength = 0;
		
		foreach (string s in sringsToAlign)
		{
			if (s.Length > maxLength)
			{
				maxLength = s.Length;
			}
		}
		//выравниваем все строки, приводя их к максимальной длинне
		for (int i = 0; i < stringsToAlign.Count; i++)
		{
			stringToAlign[i] = stringToAlibn[i].PadRight(maxLength+1);
		}
		//выводим получившиеся строки
		Console.WriteLine("Те же имена выровнены и имеют одинаковую длинну");
		
		foreach (string s in stringsToAlign)
		{
			Console.WriteLine("Имя '" + s + "' после обработки");
		}
		
		//ожидаем подтверждения пользователя
		Console.WriteLine("Нажмите <Enter> для завершения программы...");
		Console.Read();
	}
}
```

`AlignOutput` опред. список имен `List<string>` с разным выравниванием и длинной 
(можно переписать программу, чтобы имена считывались с клавиатуры или из файла).
Функция `Main()` выводит имена на экран в том виде, в котором они получены программой. 
Потом вызываются методы `Trim()` и `PadRight()`, улучшающие внешний вид выводимых программой строк:

```
Следующие имена имеют разные длины:
Имя `Christa ` до обработки
Имя ` Sarah` до обработки
Имя `Jonathan` до обработки
Имя `Sam` до обработки
Имя ` Schmekowitz` до обработки

Те же имена выровнены и имеют одинаковую длину:
Имя `Christa    ` после обработки
Имя `Sarah      ` после обработки
Имя `Jonathan   ` после обработки
Имя `Sam        ` после обработки
Имя `Schmekowitz` после обработки
```

Процесс выравнивания начинается с созд. копии переданного массива `names`.
Код начинается с цикла, вызывающего `Trim()` для каждого элем. массива, 
чтобы удалить лишние пробельные символы с обоих концов строки.
Потом вып. второй цикл, поиск самого длинного элем. массива.
Последний цикл, для элем. массива вызывается метод `PadRight()`, удлиняющий строки и делющий их равными по длине.
Метод `PadRight(10)` увел. строку, чтобы её длина сост. минимум 10 символов.
прим.
Если длина исходной строки - 6 символов, то `PadRight(10)` добавит справа 4 пробела.
Далее вывод на экран.

#### использование метода Concat()
Иногда возникает задача разбиения строки или вставки подстроки в середину другой строки.
Заменить один символ можно с пом. метода `Replace():`

```
string s = "Danger NoSmoking";
s = s.Replace(' ', '!')
```

Этот фрагмент преобразует начальную строку в `Danger!NoSmoking`.
Замена опред. символов ( ) другим (!) полезна при генерации списка элементов, разделенных запятыми для упрощения анализа.
Более распространенный и сложный случай предусматривает разбиение единой строки на подстроки, 
отдельную работу с каждой подстрокой с послед. объединением в единую модифицированную строку.

Программа `RemoveWithSpace` исп. метод `Concat()` для удаления из строки пробельных символов.

```
using System
//RemoveWhiteSpace - удаление символов из предопределенного множества из заданной строки
namespace RemoveWhiteSpace
{
	public class Program
	{
		public static void Main(string[] args)
		{
			//определение множества пробельных символов
			char[] whiteSpace = {' ', '\n', '\t'};
			//начинаем работу со строкой, в которой имеются пробельные символы
			string s = " this is a\nstring";
			Console.WriteLine("До: + s");
			//выводим строку с удаленными пробельными символами
			Console.Write("После:");
			//поиск пробельных символов
			for (;;)
			{
				//ищем позиции искомых символов;
				//если таковых в строке больше нет, выходим из цикла
				int offset = s.IndexOfAny(whiteSpace);
				
				if (offset == -1)
				{
					break;
				}
				
				//разбиваем строку на две части - до найденного символа и после него
				string before = s.Substring(0, offset);
				string after = s.Substring(offset + 1);
				
				//объединяем эти части, но уже без найденного символа
				s = String.Concat(before, after);
				
				//циклически ищем след. пробельный символ в модифицированной строке s
			}
		Console.WriteLine(s);
		
		//ожидаем подтверждение пользователя
		Console.WriteLine("Нажмите <Enter> для завершения программы...");
		Console.Read();
		}
	}
}
```

Выделенный(в книге) код циклически удаляет из строки вхождения всех симвлов, содержащихся в массиве `whiteSpace`.

Цикл исп. `IndexOfAny()` для поиска первого вхождения из символов, содержащихся в массиве `whiteSpace`.
Выход из цикла не будет пока из исходной строки не будут удалены все символы.
Метод `IndexOfAny()` возвращает индекс первого найденного символа из исходного массива в строке.
Возвращаемое значение `-1` указывает, что в строке нет элементов из переданного массива.

Первая итерация цикла находит ведущий пробел в целевой строке, индекс которого равен 0, возвращается методом `IndexOfAny()`.
Первый вызов `Substring()` возвращает пустую строку, второй - всю строку после пробела.
После функция `Concat()` объединяет эти строки, созд. строку без начального пробела.

Вторая итерация находит и удаляет пробел после слова `this`, давая в результает строку `thisis a/nstring`.

3-4 итерация находятся и удаляется пробел и символ `\n`.
После этого очередной вызов `IndexOfAny()` не находит искомого символа и возвращает `-1`, 
после работа цикла завершается.

Программа сначала выводит строку, содержащую пробельные символы, затем удаляет и выводит полученную строку:

```
До: this is a
string
после:thisisastring
Нажмите <Enter> для завершения программы...
```

#### использования метода Split()

В программе `RemoveWhiteSpace` было продемонстрированно прим. методов `Concat()` и `IndexOf()`.
Эти способы решения не самые эффективные.
Можно получить более эффективную функцию с исп. функции `Split()`.

```
//RemoveSpacialChars удаляет из строки указанные символы
public static string RemoveSpecialChars(string input, char[] targets)
{
	//разбиение входной строки с исп. символов targets в качестве разделителей
	string[] subString = input.Split(targets);
	
	//строка output будет содержать выходную информацию
	string output = "";
	
	//цикл по всем подстрокам, полученным при вызове Split()
	foreach(string subString in subStrings)
	{
		output = String.Concat(output, subString);
	}
	return output;
}
```

Для разбиения входной строки на множество подстрок исп. функция `Split()` с удаляемыми символами в качестве символов разделителей.
т. к. разделители не вкл. в подстроки, созд. эффект удаления.

Цикл `foreach` в этой версии функции собирает части строки в единое целое с исп. метода `Concat()`.

### Форматирование строк

Класс `String` дает метод `Format()` для форматирования вывода (в осн. чисел).
`Format()` позволяет вставлять строки, числа, логические значения в середину форматируемой строки.
прим.
`string myString - String.Format("{0} * {1} = {2}", 2, 5, 2*5)`;

Первый аргумент метода `Format()` - *форматная строка* (строка формата).
Элементы `{n}` в ней указывают, что n-й аргумент, след. за форматной строкой, должен быть вставлен в этой точке.
`{0}` означает первый аргумент (2), {1} - второй аргумент (3) и т. д.
В приведенном фрагменте полученная строка присваивается переменной `myString`

```
"2 * 5 = 10"
```

Если не указано другое, метод `Format()` для каждого типа аргумента исп. формат по умолчанию.
Для указания формата вывода в фигурных скобках, кроме номера аргумента, можно размещать доп. модификаторы.
прим. 
`{0:E6}` - "вывод числа в экспоненциальном виде с использованием шести знакомест в дробной части".

![[С-шарп модификаторы, исп. функцией String.Foram().png|500]]
![[С-шарп модификаторы, исп. функцией String.Foram() 2.png|500]]
![[С-шарп модификаторы, исп. функцией String.Foram() 3.png|500]]
 
**совет**
Метода `Console.WriteLine()` исп. аналогичную систему замещения.
Первый элемент, `{0}`, означает первую переменную или значение первой форматной строки и т. д.
Получая те же аргументы, что и метод `Format(),Console.WriteLine()` выводит получившуюся строку на консоль.
В этом методе можно исп. те же спецификаторы формата, которые прим. в функции `Format()`.
Далее при необходимости вывода на экран будет исп. этот метод.

Модификаторы могут показаться запутанными, но о них всегда можно получить информацию в C#.
Посмотрим на модификаторы в действии, посмотрим на программу `OutputFormatControls`, 
которая позволяет вводить не только числа с плавающей точкой, но и модификатор формата, 
который будет исп. при выводе введенного числа обратно на экран:

```
//OutputFormatControls позволяет пользователю посмотреть, как влияют модификаторы форматирования на вывод чисел.
//Модификаторы вводятся в программу так же, как и числа, - в процессе работы программы
namespace OutputFormatControls
{
	using System;
	
	public class Program;
	{
		public static void Main(string[] args)
		{
			//бесконечный цикл для ввода чисел, пока пользователь не введет вместо числа пустую строку, 
			//что является сигналом к окончанию работы программы
			for(;;)
			{
				//ввод числа и выход из цикла, если введена пустая строка
				Console.WriteLine("Введите число с плавающей точкой");
				string numberInput = Console.ReadLine();
				if (numberInput.Lenght == 0)
				{
					break;
				}
				double number = Double.Parse(numberInput);
				
				//ввод модификатора форматирования, разделенных пробелами
				Console.WriteLine("(Например: C E F1 N0 0000000.00000)");
				char[] separator = {' '};
				string formatString = Console.ReadLine();
				string[] formats = formatString.Split(separator);
				
				//цикл по введенным модификаторам
				foreach(string s in formats)
				{
					if (s.Length ! = 0)
					{
						//создание управляющего элемента форматирования из введенного модификатора
						string formatCommand = "{0:" + s + "}";
						
						//вывод числа с применением созданного управляющего элемента форматирования
						Console.Write("Модификатор {0} дает ", formatCommand);
						try
						{
							Console.WriteLine(formatCommand, number);
						}
					catch(Exception)
					{
						Console.WriteLine("<Неверный модификатор>");
					}	
					Console.WriteLine();
					}
				}
			}
			//ожидаем подтверждение пользователя
			Console.WriteLine("Нажмите <Enter> для завершения программы...");
			Console.Read();
		}
	}
}
```

Программа `OutputFormatControls` считывает вводимые пользователем числа с плавающей точкой в переменную `numberInput` до тех пор, пока не будет введена пустая строка.
Для простоты программа не выполняет никаких тестов для проверки корректности введенного числа с плавающей точкой.

Далее программа считывает ряд модификаторов форматирования, разделенных пробелами.
Каждый комбинируется со строкой `{0}` в переменной `formatCommand`.
прим. 
Если вы ввели `N4`, программа создаст упр. элем. `{0:N4}`, 
после введенное пользователем число будет выведено на экран с прим. этого элемента.

```
Console.WriteLine(foramtCommand, number);
```

В рассмотренном случае `N4` команда превращается в 

```
Console.WriteLine("{0:N4}", number);
```

Вывод программы:

```
Введите число с плавающей точкой
12345.6789
Введите модификаторы форматирования, разделенные пробелами
(Например: C E F1 N0 0000000.00000)
C E F1 N0 0000000.00000
Модификатор {0:C} дает $12,345.68
Модификатор {0:E} дает 1.234568E+004
Модификатор {0:F1} дает 12345.7
Модификатор {0:N0} дает 12,346
Модификатор {0:0000000.00000} дает 0012345.67890
Введите число с плавающей точкой
.12345
Введите модификаторы форматирования, разделенные пробелами
(Например {0:00.0%}) дает 12.3%
Введите число с плавающей точкой

Нажмите <Enter> для завершения программы...
```

Примененный к числу `12345.6789`, модификатор `N0` добавляет в нужное место запятую (часть `N`) и убирает все цифры после десятичной точки (часть `0`), что дает строку `12,346`
(последняя цифра - результат округления, а не отбрасывания).

Аналогично, прим. к числу `0.12345` модификатор `00.0%` дает `12.3%`.

**технические подробности**
Непонятная (пока что) конструкция `try...catch` предназначена для перехвата всех потенциальных ошибок при вводе некорректных чисел (подробнее в гл. 9 "Эти исключительные исключения").

### StringBuilder: эффективная работа со строками

Созданная строка изм. не может.
код:
```
string s1 = "rapid";
string s2 = s1 + "ly"; // s2 = rapidly
```
не добавляет "`ly`" к `s1`. 
Он создает новую строку, сост. из этих частей (`s1` ост. неизменной).
Др. операции (прим. `Substring()`, `Replace()`), поступают также.

Результат каждой операции на строкой представляет др. строку.
Допустим, что надо соед. 1000 строк в одну большую.
Вы созд. строку при пом. множества конкатенаций:
```
string[] listOfNames = ...// 1000 имен
string s = string.Empty;
for(int i = 0; i < 1000; i++)
{
	s += listOfNames[i];
}
```

Чтобы избежать большого количества модификаций строк, восп. классом `StringBuilder`.
Не забудте добавить в начале строку
```
using System.Text; // где искать StringBuilder
```

**технические подробности**
В отличии от работы со `String`, действия c `StringBuilder` изм. строку класса непосредственно, прим:
```
StringBuilder builder = new StringBuilder("012");
builder.Append("34");
builder.Append("56");
string result = builder.ToString(); // result = 0123456
```

При создании экземпляр `StringBuilder` инициализируется сущ. строкой.
Если не указать начальное значение `StrinfBuilder`, будет исп. пустая строка:

```
StringBuilder builder = new StringBuilder(); //до 16 символов по умолчанию
```

Можно создать `StringBuilder` с треб. емкостью, 
что снизит накладные расходы на частое увеличение емкости для строки:

```
StringBuilder builder = new StringBuilder(256); //256 символов
```

Для добавления текста к концу текущего содержимого исп. метод `Append()`.
После завершения работы со строкой метод `ToString()` представит окончательный результат работы.
прим.
```
StringBuilder sb = new StringBuilder(20000); //выделение памяти
for(int i = 0; i < 1000; i++)
{
	sb.Append(listOfNames[i]); //тот же список имен
}
string result = sb.ToString(); //получение результата
```

Класс `StringBuilder` имеет ряд др. полезных методов `Insert()`, `Remove()`, `Repalce()`.
Но в нем не хватает многих методов `string` (прим. `Substring()`, `CopyTo()`, `IndexOf()`).

прим.
Вы хотите перевести в верхний регистр только первый символ строки.
Прим пом. `StringBuilder` сдел. это существенно проще

```
StringBuilder sb = new StringBuilder("jones");
sb[0] = char.ToUpper(sb[0]);
string fixedString = sb. ToString();
```

Строка `"jones"` помещается в объект `StingBuilder`, 
выполняется обращение к первому символу строки `StingBuilder` как к `sb[0]`, 
для перевода в верхний регистр исп. вызов метода `char.ToUpper()`, 
после символ в верхнем регистре вновь присваивается `sb[0]`.
Строка `"Jones"` получается при помощи метода `ToString()`.

Ранний пример `BuildASentence` может быть улучшен с прим. `StringBuilder`.

В части 2 "Объектно-ориентрованное программирование на C#" рассматривается функциональная возможность C# - *методы расширения*.
В приведенном примере к классу `String` доб. несколько удобных методов и описывается, как преобразовывать между собой данные типы `String`, массивы `char`, массивы `byte`.

## глава 4. операторы
- выполнение арифметических действий
- логические операции
- составные логические операторы

### арифметика
Арифметические операторы можно разбить на неск. групп:
простейшие арифметические операторы, операторы присваивания, специальные операторы.

#### простейшие операторы

![[С-шарп простые операторы.png]]

Большинство операторов явл. *бинарными*, т. к. они выполняются над 2-мя значениями: слева и справа от оператора.
Исключение - унарный минус.

```
int n1 = 5;
int n2 = -n1; //теперь значение n2 равно -5
```

Значение `n2` представляется как отрицательно значение `n1`.

Деление по модулю аналогично получению остатка после деления.
5 % 3 = 2 (5/3=1, остаток 2)
25 % 3 = 1 (25/3=8, остаток 1)

Арифметические операторы определены для всех типов переменных.
Оператор деления по модулю не определен для чисел с плавающей точкой, т. к. при делении значения с плавающей точкой не существует остатка.

#### порядок выполнения операторов
Значения выражений могут показаться непонятными. 
прим. рассмотрим следующее выражение:
```
int n = 5 * 3 + 2;
```

**запомни**
Язык C# обычно вып. операторы слева направо, умножение выполняется до сложения.
Результатом прим. будет 17.

```
int n = 24 / 6 / 2
```
ответ = 2

У операторов есть *иерархия*, порядок выполнения.
C# считывает всё выражение и определяет, какие операторы имеют наивысший приоритет.

**запомни!**
Никогда не полагайтесь на то, что вы помните приоритеты операторов.
Стоит указывать порядок выполения с пом. скобок.

```
int n = (7 % 3) * (4 + (6 / 3));
```

Скобки перекрывают приоритеты операторов, указывая как именно компилятор должен интерпретировать выражение.
C# ищет наиболее глубоко вложенную пару скобок и вычисляет выражение в ней.
ответ = 6

#### оператор присваивания
Присваивания явл. бинарным оператором, возвращающим значение аргумента справа от него.
Присваивание имеет тот же тип, что и оба аргумента.

```
n = 5 * 3;
```

`5*3=15` имеет тип `int`.
Оператор присваивания сохр. значение `int` справа в переменной `int` слева и возвращает значение 15.
Это позволяет сохр. значение в ещё одной переменной.

```
m = n = 5 * 3;
```

Если есть неск. присваиваний, то они вып. справа-налево.
В прим. выше правый оператор сохр. значение `15` в переменной `n` и возвращает 15, 
левый оператор присваивания сохр. значение `15` в переменной `m` и возвращает 15
(это возвращенное значение в данном примере больше никак не исп.)

Такое странное опред. присваивания делает корректным данным пример:

```
int n;
int m;
n = m = 2;
```
**совет**
Старайтесь избегать цепочек присваиваний, 
т. к. они менее понятны человеку, читавшему исходный текст программы. 
Всё, что может запутать человека, читающего исходный текст программы, след. избегать, любые неточности ведут к ошибкам.

#### оператор инкремента

```
n = n + 1; //увеличение n на 1
```

C# расширяет множество простых операторов набором присваивающих операторов, 
построенных из арифметического оператора и оператора присваивания.

прим. `n+=1` эквивалентно `n=n+1`;

Присваивающие версии операторов имеются почти для каждого бинарного оператора: `+=, -=, *=, /=, %=, &=, |=, ^=`
Это не достаточно кратко, с C# имеется более краткое обозначение действия - оператор инкремента.

```
++n; //увеличение n на 1
```

Все 3 выражения функционально эквиваленты, 
все они увеличивают значение `n` на `1`.

Оператор инкремента странен, еще более странным он становится что на самом деле есть 2 оператора инкремента: `++n` и `n++`.
`++n` - *префиксный*, `n++` - *постфиксный*.
прим. 

```
int n;
n = 1;
int p = ++n;
n = 1;
int m = n++;
```

p = 2, m = 1.
т. е. значение выражения `++n` - это значение *после* увеличения, 
значение `n++` равно значению `n` *до* увеличения.
Значение `n` в обоих вариантах равно `2`.

Эквивалентные операторы декремента, `n--` и `--n`, исп. для замены выражения `n=n-1`. 
Они работают точно также, как операторы инкремента.

### логично ли логическое сравнение

Операторы *логического сравнения*, т. к. они возвращают результат сравнения в виде значения `true` или `false`, имеющего тип `bool`.

![[С-шарп логические операторы сравния 1.png|500]]
![[С-шарп логические операторы сравния 2.png|500]]

прим.

```
int m = 5;
int n = 6;
bool b = m > n;
```

Переменной `b` присваивается значение `false`, т. к. 5<6.

Логические сравнения опред. для всех числовых типов `float, double, decimal, char`.

```
bool b;
b = 3 > 2; //true
b = 3.0 > 2.0; //true
b = `a` > `b`; //false - позже в алфавитном порядке означает "больше"
b = `A` < `b`; // true - прописная `А` больше строчной `a`
b = `A` < `b`; // true - все прописные буквы меньше всех строчных
b = 10M > 12M; // false
```

Операторы сравнения всегда дают величину `bool`.
Операторы сравнения, отличные от `==`, неприменимы к переменным типа `string`.

#### сравнение чисел с плавающей точкой
Сравнение 2-х чисел с плавающей точкой может легко оказаться не вполне корректным, здесь нужно быть осторожным.

```
float f1;
float f2;
f1 = 10;
f2 = f1 / 3;
bool b1 = (3 * f2) == f1; //b1 равно true, если (3*f2) равно f1
f1 = 9;
f2 = f1 / 3;
bool b2 = (3 * f2) == f1;
```

Единственное отличие между `b1` и `b2` сост. в исходном знач. `f1`. 
Чему равны значения `b1` и `b2`
`b1 = true`

**внимание!**
Значение `b1` не столько очевидно:
10/3=3,33...
3,33... * 3 = 9,99...
Равны ли 9,99... и 10?
Способ округления значений мат. операциями может повлиять на результат сравнения, нужно проявлять осторожность, 
делая предположения о результатах мат. операций.
Не смотря на то что 2 значения представляются потенциально равными, для копмьютера это не так.
Использование == с числами с плавающей точкой обычно не рекомендуется ввиду возм. внесения ошибки в код.

**технические подробности**
Чтобы обойти вопросы округления и сравн. значение f1 и f2, можно восп. функцией для вычисления абсолютного значения след. образом:

```
Math.Abs(f1-f2*3.0)<.00001; //...или др. степень точности.
```

Такая функция вернет значение `true` в обоих случаях. 
Вместо `.00001` можно исп. константу `Double.Epsilon`, чтобы получ. максимальную точность. 
Эта константа представляет наименьшую возм. разницу между 2-мя неравными значениями типа `double`.

#### составные логические операторы

Для переменных `bool` есть специфичные для них операторы, см. табл.

**запомни!**
Оператор `!` (НЕ) представляет собой логический эквивалент знака "минус". 
Например, `!a` истинно, если `a` ложно, и ложно, если `a` истинно.

![[С-шарп составные логические операторы.png|500]]

След. 2 оператора также просты и понятны. 
`a&b` истинно когда `a` и `b` одновременно равны `true`;
`a|b` истино тогда, когда `a` или `b` одновременно равны `true`.
Оператор `^` (*исключающее или*) возвр. значение `true` тогда, когда значения a и b различны (a = true, b = false).
Все перечисленные операторы возвр. в качестве результата значение `bool`.

**технические подробности**
Операторы `& | ^` имеют версии, назыв. *побитовые* (bitwise).
При прим. к переменной типа `int` эти операторы вып. дейст. с каждым битом отдельно.
6 & 3 равно 2 (0110 & 0011 = 0010)
6 | 3 равно 7 (0110 | 0011 = 0111)
6 ^ 3 равно 5 (0110 ^ 0011 = 0101)
Бинарная арифметика - интересная вещь, но в книге она не рассматривается.

Последние 2 оператора похожи на предыдущие, но имеют одно отличие. 
прим.

```
bool b = (ЛогическоеВыражение1) & (ЛогическоеВыражение2);
```

C# вып. `ЛогическоеВыражение1` и `ЛогическоеВыражения2` и смотрит, равны они оба `true` или нет, 
чтобы найти, какое значение след. присвоить переменной `b`.
Может оказаться что C# вып. лишнюю работу, ведь одно из выражений равно `false`, 
но оператор `&` вычислить оба выражения.

Оператор `&&` позволит избежать вычисление второго выражения, 
если после первого результат очевиден:

```
bool b = (ЛогическоеВыражение1) && (ЛогическоеВыражение2);
```

В этой ситуации C# вычисляет значение `ЛогическоеВыражение1`, если оно `false`, то переменной `b` присваивается значение `false` и `ЛогическоеВыражение2` не вычисляется.

Оператор `&&` исп. *сокращенное вычисление*.

**совет**
Большинство программистов исп. оператор `&&`, а не `&`.

Оператор `||` работает аналогично:
```
bool b = (ЛогическоеВыражение1) || (ЛогическоеВыражение2);
```
В этой ситуации C# вычисляет знач. `ЛогическоеВыражение1`, и если оно равно `true`, то переменная `b = true`.
Если `ЛогическоеВыражение1` равно `false`, то C# вычисляет `ЛогическоеВыражение2` и опред. какое значение присвоить `b`.

Можно называть эти операторы "сокращенное И" и "сокращенное ИЛИ".

**технические подробности**
Некоторые программисты полагаются на стандартные операторы для вып. конкретных задач.
Например, если выражение должно вып. некоторое действие, а не только предоставить значение, 
не след. исп. сокращенный оператор, т. к. при этом C# может не вып. второе действие.

### Тип выражения
В вычислениях тип результата важен не менее самого результата. 
прим.
```
int n;
n = (5 * 5) + 7;
```

Выражение имеет не только значение, но и тип.
Записанное на "языке типов", оно принимает след. вид:
```
int [=] (int * int) + int;
```

#### вычисление типа операции
Большинство операторов могут имеет неск. вариантов.
Оператор умножения может быть след. видов:
```
int * int => int
uint * uint => uint
long * long => long
float * float => float
decimal * decimal => decimal
double * double => double
```

##### неявное преобразование типов

Что будет если переменожить переменные разных типов?
прим.
```
int anInt = 10;
double aDouble = 5.0;
double result = anInt * aDouble;
```

В С# нет оператора умножения `int*double`.
С# мог бы преобразовать `aDouble` в `int`, но такое преобразование привело бы к потере дробной части.
Поэтому он преобразует `anInt` в тип `double` и исп. оператор `double * double`.
Это действие известно как *неявное повышение типа* (implicit promotion).

Такое повышение называется *неявным*, т. к. C# вып. его автоматически и явл. *повышением*, т. к. вкл. концепцию высоты типа.
Список операторов приведен в порядке повышения.
Между типами с плавающей точкой и `decimal` неявное преобразование не выполняется.
Преобразование из более емкого типа `double`, в менее емкий `int`, называется `понижением` (denotion).

**внимание!**
Неявные понижения запрещены.
В таких случаях C# показывает сообщение об ошибке.

##### явное преобразование типов
Можно изм. любой тип переменной с помощью оператора *приведения* (cast), 
который представляет собой требуемый тип, заключенный в скобки и распологаемый непосредственно перед приводимой переменной или выражением.
В след. выражении исп. оператор умножения `int*int`:

```
int anInt = 10;
double aDouble = 5.0;
int result = anInt * (int)aDouble;
```

Приведение `aDouble` к типу `int` известно как *явное понижение* (explicit demotion) или *понижающее приведение* (downcast).
Понижение является явным, т. к. программист явно объявил о своих намерениях.

**запомни!**
Вы можете осуществить приведение между двумя любыми типами-значениями, независимо от их взаимной высоты.

**совет**
Избегайте неявного преобразования типов. 
Делайте все изменения типов-значений явными с пом. оператора приведения - это снижает вероятность непреднамеренной ошибки и повышает удобочитаемость кода.

##### оставте логику в покое
Язык C# не позволяет преобразовывать другие типы в тип `bool` и наоборот.

#### типы при присваивании
Все описанное о типах выражений применимо к оператору присваивания

**внимание!**
Случайные несоответствия типов, приводящие к генерации сообщений об ошибках, обычно происходят в операторах присваивания, а нев точке действительного несоответствия.
прим.

```
int n1 = 10;
int n2 = 5.0 * n1;
```

Вторая строка приведет к сообщению об ошибке, 
но ошибка возникла *при присваивании*, а не при умножении.

Что произошло:
```
1. чтобы вып. умножение, C# неявно преобразовал n1 в тип double
2. выполнил умножение 2-х значений типа double
3. результат значение типа double
4. тип левого и правого аргументов должны совпадать, но тип левого аргумента не может быть изм.
5. C# не может неявно преобразовать double => int
```

При исп. явного преобразования проблем не возникает
```
int n1 = 10;
int n2 = (int)(5.0 * n1);
```
Скобки необходимы, потому что оператор приведения имеет очень высокий приоритет.

#### перегрузка операторов
Поведение любого оператора можно изм. с пом. функциональной возм. C#, 
которая называется *перегрузкой оператора* (operator overloading).
Перегрузка оператора, опред. новую функцию, которая вып. в любой момент, когда вы исп. оператор в проекте, где определена перегрузка.

```
var x = 2+2;
```
Можно ожидать, что x=4.
Но чтобы сделать жизнь интереснее, предоставим пользователям больше, чем они хотят, при каждой операции сложения будем доб. ещё 1.

Для доб. 1 при каждой операции сложения необходимо созд. пользовательский класс, который может исп. перегруженный оператор. 
Этот класс будет иметь некоторые пользовательские типы и метод, 
который будет исп. при перегрузки операции.
т. е. при суммировании обычных чисел выполучите правильный ответ, 
если вы доб. спец. числа `AddOne`, то будет прибавлена лишняя единица:

```
public class AddOne
{
	public int x;
	public static AddOne operator +(AddOne a, AddOne b)
	{
		AddOne addone = new AddOne();
		addone.x = a.x + b.x + 1;
		return addone;
	}
}
```

после перегрузки оператор можно исп. как обычно:

```
public class Program
{
	static void Main(string[] args)
	{
		AddOne foo = new AddOne();
		foo.x = 2;
		AddOne bar = new AddOne();
		bar.x = 3;
		//теперь 2 + 3 равно 6...
		Console.WriteLine((foo + bar).x.ToString());
		Console.Read();
	}
}
```
В результате мы получаем не 5, а 6. 
Перегрузка оператора не явл. чем то полезным для целых чисел. 
Но если у вас есть сущности, для которых вы хотите иметь возм. суммирования, этот метод может быть полезным.
прим.
если у вас есть класс `Product`, вы можете переопределить оператор `+` для этого класса для доб. цены.

## глава 5. управление потоком выполнения
Рассмотрим программу
```
using System;
namespace HelloWorld
{
	public class Program
	{
		//старотовая точка программы
		static void Main(string[] args)
		{
			//приглашение для ввода имени
			Console.WriteLine("введите имя:");
			//считывание введенного имени
			string name = Console.ReadLine();
			//приветствие с исп. введенного имени
			Console.WriteLine("привет, " + name);
			//ожидание подтверждения пользователя
			Console.WriteLine("нажмите <Enter> для завершения программы");
			Console.Read();
		}
	}
}
```
Смысла в этой программе не много.
Можно представить более сложный прим. программы, но эта программа будет очень ограничена в своей функциональности.

Ключевой элемент любого комп. процессора явл. возм. принимать решения.
"принимать рещения" - процессор может пустить поток выполнения команд по тому или иному пути в зависимости от того, ложно или истинно некоторое условие.

3 фундаментальных вида *управления потоком*: if, цикл, безусловный переход.

### Ветвление с использованием if и switch

Основа принятия решения в C# явл. конструкция if:
```
if (условие)
{
	//этот код выполняется, если условие истинно
}
//этот код выполняется независимо от истинности условия
```
За оператором `if` в круг. скобках содержится *условное выражение* типа `bool`, 
после след. блок кода, заключенный в фигурные скобки.
Если условное выражение истино `true` -> программа вып. код в фигурных скобках.
Если нет -> код программы опускается.

прим.
```
//гарантируем, что а - неотрицательно:
//если а меньше 0...
if (a < 0)
{
	//...присваиваем этой переменной значение 0
	a = 0;
}
```
В этом фрагменте проверяется, содерж. ли переменная `a` отриц. значение, если да, переменной `a` присваивается знач. `0`.

**технические подробности**
Если в фигурные скобки заключена только одна инструкция, то их можно не использовать.
C# рассматирвает код `if(условное выражение) инструкция;` как если бы оно было записано как `if(условное выражение){инструкция;}`, т. е. в прим. выше можно написать `if (a<0) a=0;`.
Но для улучшения читабельности лучше всегда исп. фигурные скобки.

#### инструкция if
Рассмотрим программу, вычисляющую проценты. 
Пользователь вводит вклад и проценты, программа подсчитывает сумму, получ. по итогам года.

```
//вычисление суммы вклада и процентов
deciamal interestPaid;
interestPaid = principal * (interest / 100);
//вычисление общей суммы
decimal total = principal + interestPaid;
```

Программа должна учитывать, что данные вводит человек, которому свойственно ошибаться.
В след. программе `CalculateInterest` вып. след. проверки:

```
//CalculateInterest
//вычисление величины начисленных процентов для данного вклада.
//если процентная ставка или вклад отрицателен, генерируется сообщение об ошибке.
using System;
namespace CalculateInterest
{
	public class Program
	{
		public static coid Main(string[] args)
		{
			//приглашение для ввода вклада
			Console.Write("введите сумму вклада:");
			string principalInput = Console.ReadLine();
			decimal principal =
				Convert.ToDecimal(principalInput);
			//убеждаемся, что вклад не отрицателен
			if (principal < 0)
			{
				Console.WriteLine("Вклад не может быть отрицательным");
				principal = 0;
			}
			//приглашение для ввода процентной ставки
			Console.Write("Введите процентную ставку:");
			string InterestInput = Console.ReadLine();
			decimal interest =
				Convert.ToDecimal(interestInput);
			//убеждаемся что процентная ставка не отрицательная
			if (interest < 0)
			{
				Console.WriteLine("Процентная ставка не может быть отрицательной");
				interst = 0;
			}
			//вычисляем сумму величины процентных начислений и вклада
			decimal interestPaid;
			interestPaid = principal * (interest / 100);
			//вычисление общей суммы
			decimal total = principal + interestPaid;
			//вывод результатов
			Console.WriteLine(); //пропуск строки
			Console.WriteLine("Вклад = " + principal);
			Console.WriteLine("Проценты = " +interest+ "%");
			Console.WriteLine();
			Console.WriteLine("Начисленные проценты = " + interestPaid);
			Console.WriteLine("Общая сумма = " + total);
			//ожидание реакции пользователя
			Console.WriteLine("нажмите <Enter> для завершения программы");
			Console.Read();
		}
	}
}
```

**совет**
Программа `CalculateInterest` начинает работу с предложения пользователю ввести величину вклада.
Это предложение выводится с помощью функции `WriteLine()`, которая выводит значение типа `string` на консоль.
Всегда точно объясняйте пользователю, чего вы от него хотите. 

**запомни!**
Команды `ReadLine()`, `WriteLine()`, `ToDecimal()` служат прим. *вызовов методов*.
Вызов метода делегирует некоторую работу другой части программы, именуемой методом.

прим. вывода программы
```
введите сумму вклада: 1234
введите процентную ставку: 21

вклад = 1234
проценты = 21%

начисленные проценты = 259,14
общая сумма = 1493,14
нажмите <Enter> для завершения программы...
```

**совет**
Отступ внутри блока `if` повышает удобочитабельность.
C# игнорирует все отступы, но для человека они весьма важны.
Большинство редакторов автоматически доб. отступ после `if`.

#### Инструкция else
Некоторые функции должны проверять взаимоисключающие условия. 
прим. 
В переменной `max` сохр. наибольшее значение `a` или `b`.

```
//сохр. наибольшее из 2-х значений a и b, в переменной max
int max;
//если a>b
if (a > b)
{
	//сохр. a в переменной max
	max = a;
}
//если a<=b
if (a <= b)
{
	//сохр. b в переменной max
	max = b;
}
```

Вторая `if` лишняя, т. к. проверяемые условия взаимоисключающие.
Для таких случает в C# исп. `else`, позволяющее указывать блок, который выполняется, если не вып. блок `if`.
прим.
```
//сохр. наибольшее из 2-х значений a и b, в переменной max
int max;
//если a>b
{
	//сохр. a в переменной max
	max = a;
}
else //в противном случае
{
	//сохр. b в переменной max
	max = b;
}
```

#### как избежать else
При наличии неск. `else` легко запутаться, 
поэтому некоторые программисты избегают исп. `else`, если оно приводит к ухудшению читабельности кода.
прим.
```
//сохр. наибольшее из 2-х значений a и b, в переменной max
int max;
//начнем с предположения, что a > b
max = a;
//если это не так
if (b>a)
{
	//то сохр. b в max
	max = b;
}
```

**совет**
Программисты, считающие себя "крутыми", часто исп. *терминарный оператор* `?:`, однострочный эквивалент `if/else`:
```
bool informal = true;
string name = informal : "Chuck" ? "Charles"; //вернет "Chuck"
```

#### Вложенные инструкции if
Программа `CalculateInterest` предупреждает пользователя о неверном вводе, но продолжает вычислять начисленные проценты, несмотря на некорректность введенных значений.
Необходимы 2 конструкции `if`, одна внутри другой, чтобы программа продолжала работу только если данные были введены правильно.

**запомни!**
Инструкция `if`, находящаяся в теле др. инструкции `if`, назыв. *встроенной* (embedded) или *вложенной* (nested).
Приведенная далее программа `CalculateInterestWithEmbeddedTest` исп. вложенную инструкцию `if`, чтобы избежать лишних вопросов при обнаружении некорректного ввода пользователя:

```
//CalculateInterestWithEmbeddedTest
//Вычисление величины начисленных процентов для данного вклада.
//Если процентная ставка или вклад отрицательный, 
//генерируется сообщение об ошибке и вычисление не выполняется.
using System;

namespace CalculateInterestWithEmbeddedTest
{
	public class Program
	{
		public static void Main(string[] args)
		{
			//опред. максимально возможное значение процентной ставки
			int maximumInterest = 50;
			
			//приглашение пользователю ввести величину исходного вклада
			Console.Write("введите сумму вклада:");
			string principalInput = Console.ReadLine();
			decimal principal = Convert.ToDecimal(principalInput);
			
			//если исходный вклад отрицателен
			if (principal < 0)
			{
				//генерируем сообщение об ошибке
				Console.WriteLine("Вклад не может быть отрицательным");
				
			}
			else //сюда попадаем, только если principal >= 0
			{
				//в противном случае просим ввести процентную ставку
				Console.Write("Введите процентную ставку:");
				string interestInput = Console.ReadLine();
				decimal interest = Convert.ToDecimal(interestInput);
				
				//если процентная ставка отрицательна или слишком высока
				if (interest < 0 || interest > maximumInterest)
				{
					//генерируем сообщение об ошибке
					Console.WriteLine("Процентная ставка не может быть отрицательной или превышать " + maximumInterest);
					interest = 0;
				}
				else //сюда попадаем если всё в порядке
				{
					//Величина вклада и процентная ставка корректны 
					//- можно приступить к вычислению вклада с начисленными процентами
					decimal interestPaid;
					interestPaid = principal * (interest / 100);
					
					//вычисляем общую сумму
					decimal total = principal + interestPaid;
					
					//выводим результат
					Console.WriteLine(); //скип строки
					Console.WriteLine("Вклад = " + principal);
					Console.WriteLine("Проценты = " + interest + "%");
					Console.WriteLine();
					Console.WriteLine("Начисленные проценты = " + interestPaid);
					Console.WriteLine("Общая сумма = " + total);
				}
			}
			//ожидание реакции пользователя
			Console.WriteLine("нажмите <Enter> для завершения программы");
			Console.Read();
		}
	}
}
```
Программа:
1. считывает введенную пользователем величину
2. если значение отрицательно, выводит ошибку и завершает работу
3. если величина положительная, упр. переходит к блоку `else`

Программу усовершенствована. 
Она треб. не только, чтобы значение было не отрицательным, но и не больше максимального значения.
```
if (interest < 0 || interest > maximumInterest)
```
Выражение истино, если `interest` меньше 0 или больше `maximumInterest`.
Обратите внимание что `maximumInterest` объявлено в начале программы, а не *жестко закодированное* (прошитое) значение.

Жестко закодированное (прошитое) значение - это значение, которое указывается непосредственно в коде вместо создания константы для его хранения.

**совет**
Опред. важные константы в начале программы с исп. описательных символьных имен. 
Это позволяет легко находить и изм. константы.
Если константва встречается неск. раз, для её изм. достаточно ввести только одно изм. а не несколько.

#### конструкция swich
Часто возникает необходимость сравнивать переменную с разными значениями.
прим. 
Переменная `maritalStatus =`:
- 0 для холостяков
- 1 для семейных
- 2 для разведенных
- 3 для вдов
- 4 (не ваше дело)
Чтобы по разному отреагировать на различные значения этой переменной, 
можно воспользоваться серией инструкций `if`:
```
if (maritalStatus == 0)
{
	//действия для холостяков
}
else
{
	if (maritalStatus == 1)
	{
		//действия для семейных
		
		//и т. д.
	}
}
```
Получается весьма неуклюжая конструкция.
В C# есть спец. конструкция для выбора множества взаимоисключающих условий `switch`:
```
switch(maritalStatus)
{
	case 0:
		//действия для холостяков/незамужних
		break;
	case 1:
		//действия для семейных
		break;
	case 2:
		//действия для разведенных
		break;
	case 3:
		//действия для вдов
		break;
	case 4:
		//действия для неизвестного семейного состояния
		break;
	default:
		//действия, когда переменная принимает значение, 
		//отличающееся от всех перечисленных выше
		//(по всей видимости, это означает, что произошла какая то ошибка)
		break;
}
```
1. Сначала вычисляется выражение в круглых скобках после ключевого слова `switch`.
2. В данном случае это значение переменной `maritalStatus`
3. Вычисленное значение сравнивается со значениями каждого из операторов `case`.
4. Если нужное значение не найдено, упр. передается операторам, после `default`.

Аргументом оператора `switch` может быть строка `string`:
```
string s = "Davis";
switch(s)
{
	case "Mallory":
		//некоторые действия
		break;
	case "Wells":
		//некоторые действия
		break;
	case "Arturo":
		//некоторые действия
		break;
	case "Brown":
		//некоторые действия
		break;
	default:
		//действия, если такой фамилии нет в списке
}
```
**запомни**
При прим. конструкции `switch` действует ряд ограничений.
- аргумент инструкции `switch()` должен иметь перечислимый тип или тип `string`.
  Нельзя исп. числа с плавающей точкой.
- значение `case` должны иметь тот же тип, что и аргумент инструкции `switch`.
- значение `case` должны быть константами в том смысле, что их значения должны быть известны во время компиляции
  (инструкция наподобие `case x` некорректна, если `x` не явл. константой).
- каждая конструкция `case` должна завершаться оператором `break` 
  (или какой-то иной командой выхода, например `return`).
  Оператор `break` передает управление за пределы конструкции `switch`.
- Допускается отсутствие `break` у `case` в том случае, когда неск. `case` приводят к одним и тем же действиям, 
  т. е. одному блоку кода соответствует несколько `case`, как в прим:
```
string s = "Davis";
switch(s)
{
	case "Davis":
	case "Hvidsten":
		//действия для s, равного "Davis", те же, что и для равного "Hvidsten"
		break;
	case "Smith":
		//...действия для "Smith"...
		break;
	default:
		//действия, если такой фамилии нет в списке
		break;
}
```
Этот подход позволяет программе вып. одни и те же действия для строки `Davis`, и для строки `Hvidsten`.

### Циклы
Конструкция `if` позволяет программе выполнятся различными путями в зависимости от результата вычисления типа `bool`. Она обеспечивает возм. создавать более интересные программы.
Ещё одним применением машинной команды условного перехода явл. возм. *повторяющегося*, итеративного вып. блока кода.

Рассмотрим программу `CalculateInterest` из раздела "Инструкция if" данной главы.
Простые вычисления удобнее выполнять с пом. карманного калькулятора, чем писать программу.

Но если необходимо вычислить проценты по вкладу для нескольких лет?
Такая программа будет намного полезнее (хотя есть Excel).
Нужно выполнить последовательность инструкций несколько раз, это *цикл* (loop).

#### цикл while
Наиболее фундаментальный вид цикла созд. с пом. `while`:
```
while(условие)
{
	//код, повторно выполяемый до тех пор, пока условие не станет ложным
}
```
При первом обращении к циклу вычисляется условие в скобках. 
Если оно истино, вып. условие. 
За ним блок кода - тело цикла.
По окончании вып. тела цикла программа вновь возвращается к началу цикла и вычисляет условие в круглых скобках и все начинается сначала.
Если в какой то момент условие становится ложным, тело цикла не вып. и упр. передается коду, после него.

**запомни!**
Если при первом обращении к циклу условие ложно, тело цикла не выполняется ни одного раза.

**внимание!**
Программисты зачастую косноязычны и могут не совсем корректно выражаться. 
Например, говоря о цикле `while`, они могут сказать, что тело цикла вып. до тех пор, 
пока условие не станет ложным.
Но такое опред. не совсем корректно, т. к. можно решить, что вып. цикла прервется в тот момент, как только условие станет ложным, это не так.
Программа не проверяет постоянно правдивость условия;
проверка производится только тогда, когда управление передается в начало цикла.

Цикл `while` можно исп. для созд. программы `CalculateInterestTable`, явл. версией программы `CalculateInterest` с прим. цикла. Она вычисляет таблицу величин вкладов по годам.

```
//CalculateInterestTable
//вычисление величины начисленных процентов для данного вклада за определенный период
using System;
namespace CalculateInterestTable
{
	using System;
	
	public class Program
		{
		public static coid Main(string[] args)
		{
			//опред. максимально возможное значение процентной ставки
			int maximumInterest = 50;
			
			//приглашение пользователя ввести величину исходного вклада
			Console.Write("Введите сумму вклада:");
			string principalInput = Console.ReadLine();
			decimal principal = Convert.ToDecimal(principalInput);
			
			//если исходный код отрицательный...
			if (principal < 0)
			{
				//...генерируем сообщение об ошибке...
				Console.WriteLine("Вклад не может быть отрицательным");
			}
			else
			{
				//...в противном случае просим ввести процентную ставку
				Console.Write("Введите процентную ставку:");
				string interestInput = Console.ReadLine();
				decimal interest = Convert.ToDecimal(interestInput);
				
				//если процентная ставка отрицательна или слишком велика...
				if (interest < 0 || interest > maximumInterest)
				{
					//...генерируем сообщение об ошибке
					Console.WriteLine("Процентная ставка не может быть отрицательно или превышать maximumInterest");
					interest = 0;
				}
				else
				{
					//и величина вклада, и процентная ставка корректны - запрашиваем у пользователя срок, 
					//для которого след. вычислить величины вкладов с начисленными процентами
					Console.Write("Введите количество лет:");
					string durationInput = Console.ReadLine();
					int duration = Convert.ToInt32(durationInput);
					
					//Выводим введенные величины
					Console.WriteLine(); //пропуск строки
					Console.WriteLine("Вклад = " + principal);
					Console.WriteLine("Проценты = " + interest + "%");
					Console.WriteLine("Срок = " + duration + " лет");
					Console.WriteLine();
					
					//цикл по указанному пользователем количеству лет
					int year = 1;
					while(year <= duration)
					{
						//вычисление вклада с начисленными процентами
						decimal interestPaid;
						interestPaid = principal * (interest / 100);
						
						//вычисляем новое значение вклада
						principal = principal + interestPaid;
						
						//округляем величину до центов
						principal = decimal.Round(principal, 2);
						
						//выводим результат
						Console.WriteLine(year + "-" + principal);
						
						//переходим к след. году
						year = year + 1;
					}
				}
			}
			//ожидание подтверждения пользователя
			Console.WriteLine("нажмите <Enter> для завершения программы");
			Console.Read();
		}
	}
}
```
Как выглядит вывод программы:
```
Введите сумму вклада: 1234
Введите процентную ставку: 12,5
Введите количество лет: 10

Вклад = 1234
Проценты = 12,5%
Срок = 10 лет

1-1288,25
2-1561,78
3-1757,00
4-1976,62
5-2223,70
6-2501,66
7-2814,37
8-3166,17
9-3561,94
10-4007,18
нажмите <Enter> для завершения программы
```
Каждое значение представляет общую сумму вклада по истечении указанного срока в предложении, что начисленные проценты доб. к основному вкладу. 
Сумма 1234$ при ставке 12,5% за 9 лет превращается в 3561,94$

**технические подробности**
В большинстве значений для количества копеек выделяется 2 цифры. 
Однако в некоторых версиях C# завершающие нули могут не выводится, и сумма 12,70 может оказаться выведенной как 12,7. Это поведение C# можно исправить с пом. спец. форматирующих символов, описываемых в главе 3 "работа со строками".
(C# 2.0 выводит завершающие нули по умолчанию).

1. Программа `CalculateInterestTable` начинает работу со считывания величины вклада, процентной ставки и проверки корректности ввода.
2. Далее считывает количество лет, для которых надо подсчитать величины вкладов
3. Далее сохраняет их в переменной `duration`.
4. Прежде чем войти в цикл `while`, программа объявляет переменную `year` со знач. 1.
5. Если номер года, хранящийся в переменной `year`, меньше общего количества лет, в переменной `duration`,
   величина вклада для этого года вычисляется исходя из предыдущего года.
6. Вычисленное значение программа выводит со значением текущего года.

**технические подробности**
Инструкция `decimal.Round()` округляет вычисленное значение до центов.

Ключевая часть программы находится в последней строке цикла.
Выражение `year = year + 1;` увеличивает переменную `year` на 1.
После увеличения значения года управление передается в начало цикла, 
где величина `year` сравнивается с запрошенным количеством лет.

Переменная-счетчик `year` должна быть объявлена до цикла `while`, в котором она исп. 
Переменная `year` должна увеличиваться.
Как в прим. вы должны заранее позаботится о том, какие переменные понадобятся в цикле.

**внимание!**
При написании цикла `while` не забывайте увеличивать значение счетчика.
```
int nYear = 1
while (nYear < 10)
{
	//код
}
```
В этом прим. `nYear` не увеличивается. 
Без увеличения переменная `nYear` всегда содержит значение 1 и цикл работает вечно.
Эта ситуация назыв. *зацикливанием* (бесконечный цикл, infinite loop).
Единственный способ прекратить зацикливание - аварийно завершить программу.

**запомни!**
Убедитесь в том, что условие прекращения работы цикла может быть достигнуто. 
Обычно это означает корректное увеличение значения счетчика цикла.
В противном случае вы получите много неприятностей...

#### цикл do...while
Разновидность цикла `while` цикл `do...while`.
При его исп. условие не проверяется, пока не будет достигнут *конец* цикла:
```
int year = 1;
do
{
	//...некоторые вычисления...
	year = year + 1;
	year (year < duration);
}
```
В противоположности циклу `while` тело цикла `do...while` всегда вып. по крайней мере один раз, независимо от значения переменной `duration`.

#### операторы break и continue
Для управления циклом имеются 2 спец. оператора - `break` и `continue`.
Оператор `break` вызывает прекращение цикла и передачу упр. первому выражению непосредственно за циклом.
Команда `continue` передает управление в начало цикла, к проверке его условия.

Например вы хотите прекратить вып. программы, как только сумма вклада превысит начальную в заданное число раз, в независимости от срока.
Это можно легко сделать, добавив след. строки:
```
//цикл по опред. колич. лет
int year = 1;

while(year <= duration)
{
	//вычислени вклада с начисленными процентами
	decimal interestPaid;
	interestPaid = principal * (interest / 100);
	
	//вычисляем новое значение вклада
	principal = principal + interestPaid;
	
	//округляем величину до центов
	principal = deciamal.Round(principal, 2);
	
	//выводим результат
	Console.WriteLine(year + "-" + principal);
	
	//переходим к след. году
	year = year + 1;
	
	//выясняем, достигли ли мы поставленной цели
	if (principal > (maxPower * originalPrincipal))
	{
		break;
	}
}
```
Опертор `break` не будет вып. до тех пор, пока условия оператора `if` не станет истиным, 
т. е. пока вычисленная величина вклада не превысит исходную в `maxPower` раз.
Оператор `break` передаст упр. за пределы цикла `while(year<=duration)`, и вып. программы продолжится с выражения, 
следующего непосредственно за этим циклом.

#### Цикл без счетчика
Программа `CalculateInterestTable` достаточно хорошо написана, чтобы завершить работу, если пользователь ввёл неверное значение.
Но программа должна давать возм. пользователю исп. ошибку.

Комбинация `while` и `break` позволяет сдел. программу более гибкой.
прим. программы `CalculateInterestTableMoreForgiving`:
```
//CalculateInterestTableMoreForgiving
//вычисление величины начисленных процентов для данного вклада за опред. период.
//программа позволяет пользователю исправить ошибку ввода величины клада и процентной ставки
using System;
namespace CalculateInterestTableMoreForgiving
{
	using System;
	
	public class Program
	{
		public static void Main(string[] args)
		{
			//опред. максимально возможное значение процентной ставки
			int maximumInterest = 50;
			
			//приглашение пользователя ввести величину исходного вклада;
			//повторяем это приглашение до тех пор, пока не будет получено корректное значение
			decimal principal;
			
			while(true)
			{
				Console.Write("Введите сумму вклада:");
				string principalInput = Console.ReadLine();
				principal = Convert.ToDecimal(principalInput);
				
				//выход из цикла, если введенное значение корректно
				if (principal >= 0)
				{
					break;
				}
				
				//генерируем сообщение о неверном вводе
				Console.WriteLine("Вклад не может быть отрицательным");
				Console.WriteLine("Повторите ввод");
				Console.WriteLine();
			}
			
			//теперь вводим величину процентной ставки
			decimal interest;
			while(true)
			{
				Console.Write("Введите процентную ставку:");
				string interestInput = Console.ReadLine();
				interest = Convert.ToDecimal(InterestInput);
				
				//если процентная ставка отрицательна или слишком велика...
				if (interest >= 0 && interest <= maximumInterest)
				{
					break;
				}
				
				//...генерируем сообщение об ошибке
				Console.WriteLine("Процентная ставка не может быть отрицательной или превышать maximumInterest");
				Console.WriteLine("Повторите ввод");
				Console.WriteLine();
			}
			
			//и величина вклада, и процентная ставка корректны - запрашиваем у пользователя срок, 
			//для которого следует вычислить величины вкладов с начисленными процентами
			Console.Write("Введите количество лет:");
			string durationInput = Console.ReadLine();
			int duration = Convert.ToInt32(durationInput);
			
			//выводим введенные данные
			Console.WriteLine(); //пропуск строки
			Console.WriteLine("Вклад = " + principal);
			Console.WriteLine("Проценты = " + interest + "%");
			Console.WriteLine("Срок = " + duration + " years");
			Console.WriteLine();
			
			//цикл по указанному пользователем количеству лет
			int year = 1;
			while(year <= duration)
			{
				//вычисление вклада с начисленными процентами
				decimal interestPaid;
				interestPaid = principal * (interest / 100);
				
				//вычисляем новое значение вклада
				principal = principal + interestPaid;
				
				//округляем величину до копеек
				principal = decimal.Round(principal, 2);
				
				//выводим результат
				Console.WriteLine(year + "-" + principal);
				
				//переходим к след. году
				year = year + 1;
			}
			//ожидание подтверждения пользователя
			Console.WriteLine("нажмите <Enter> для завершения программы");
			Console.Read();
		}
	}
}
```
Данная программа похода на предыдущие прим. кроме пользовательского ввода. 
Здесь оператор `if`, выявлявший неверный ввод пользователя, заменен циклом `while`:
```
decimal principal;
while(true)
{
	Console.Write("введите сумму вклада:");
	string principalInput = Console.ReadLine();
	principal = Convert.ToDecimal(principalInput);
	
	//выход из цикла, если введенное значение корректно
	if (principal >= 0)
	{
		break;
	}
	//генерируем сообщение об неверном вводе
	Console.WriteLine("Вклад не может быть отрицательным");
	Console.WriteLine("Повторите ввод");
	Console.WriteLine();
}
```
В представленном прим. пользовательский ввод выполняется в цикле. 
Если введенное значение корректно, программа выходит из цикла и продолжает выполнение.
Если в введенном значении есть ошибка, пользователь получает сообщение о ней и упр. передается в начало цикла.

**запомни!**
Программа вып. цикл, пока пользователь не введт корректные данные.

Обратите внимание на обращение условия, т. к. проблема теперь не в том, чтобы вывести сообщение об ошибке при некорректном вводе, а в том чтобы завершить цикл при корректном.
Проверка условия
`principal < 0 || principal > maximumInterest`
превращается в 
`interest >= 0 && interest <= maximumInterest`

Условие `interest >= 0` противоположной условию `interest < 0`.
Менее очевидна замена оператора ИЛИ `||` оператором И `&&`. 
Теперь оператор `if` гласит:
"Выйти из цикла, если процентная ставка не меньше нуля И не больше максимального значния (имеет корректную величину)".
Переменная `principal` должна быть объявлена за пределами цикла в соответствии с правилами видимости.

**внимание!**
Вычесление выражения `true` дает значение `true`. 
`while(true)` представляет собой бесконечный цикл, от зацикливания спасает только наличие `break`.
Используя `while(true)`, никогда не забывайте об операторе `break`, который должен прервать работу цикла по достижении заданного условия.

*прим. вывода программы*
...

**внимание!**
Всегда поясняйте пользователю в чем он не прав, прежде чем давать возм. исправить ошибку.

#### правила области видимости
Переменная, объявленная в теле цикла, *определена только внутри* этого цикла.
```
int days = 1;
while(days < duration)
{
	int average = value / days;
	//...некоторая последовательность операторов...
	days = days + 1;
}
```
**технические подробности**
Переменная `average` не опред. вне цикла `while`.
На это есть целый ряд причин.
При первом выполнении цикла программа встречает объявление `int average`. 
При втором объявлении цикла то же объявление встречается еще раз, 
если бы не было правила области видимости переменной, 
это привело бы к ошибке, т. к. переменная была бы уже определена.
Переменная `average` прекращает свое существование при достижении программой закрывающей фигурной скобки и вновь созд. при каждом вып. цикла.

**совет**
Опытные программисты говорят, что *область видимости* переменной `average` ограничена циклом `while`.

### Цикл for
```
for(Выражение1; Условие; Выражение2)
{
	//...тело цикла...
}
```
При достижении цикла `for` программа вып. `Выражение1`.
Затем вычисляет `Условие`, если оно истино, вып. тело цикла, которое заключено в фигурные скобки.
По достижению закрывающей скобки упр. переходит `Выражение2`, 
после вновь вычисляется `Условие` и цикл повторяется. 

Опеределение цикла `for` можно переписать как след. цикл `while:`
```
Выражение1;
while(Условие)
{
	//...тело цикла...
	Выражение2;
}
```

#### Пример
```
//некоторое выражение на C#
a = 1;
//цикл
for(int year = 1; year < duration; year = year + 1)
{
	//...тело цикла...
}
//здесь программа продолжается
a = 2;
```
Предположим, программа вып. присваивание a=1;
После она объявляет переменную `year` и инициализирует значением `1`. 
Далее программа сравнивает значение `year` со значение `duration`.
Если `year` меньше `duration`, вып. тело цикла в фигурных скобках.
По достижении закрывающей скобки программа возвращается к началу цикла и вып. инструкцию `year=year+1`, 
перед тем как перейти к проверке условия `year<duration`.

**внимание!**
Переменная `year` не определена вне области видимости цикла `for`, которая вкл. тело цикла и его заголовок.

#### зачем нужны разные циклы
Зачем нужен цикл `for`, если есть цикл `while`?
Наиболее просто ответ - не нужен.

Однако `for` повышает удобочитабельность исходных текстов, четко указывая 3 части, имеющиеся в каждом цикле:
- настройка
- условие выхода
- увеличение значения счетчика
Такой цикл проще не только для чтения и понимания, но и для проверки корректности.
Цикл `for` (и родственник `foreach`) встречается в программах на порядок чаще.

**технические подробности**
Так сложилось, что в правой части цикла `for` вып. инициализация переменной-счетчика, а в последней увеличение.
Но это не более чем традиция. В 2-х частях цикла можно вып. какие угодно действия, но для отхода от традиционной схемы нужны серьезные основания.

В цикле `for` особенно часто исп. оператор инкремента.
прим.
```
for(int year = 1; year < duration; year++)
{
	//...тело цикла...
}
```
**совет**
Почти всегда в цикле `for` прим. постфиксная форма оператора инкремента, хотя в данном случае функционально она идентична префиксной.

У цикла `for` есть одно правило:
если условие в цикле отсутствует, считается, что оно равно `true`.
Таким образом, `for(;;)` - бесконечный цикл, как `while(true)`.

### Вложенные циклы
Внутренний цикл может находится в теле другого, внещнего цикла:
```
for(...некоторое условие...)
{
	for(...некоторое др. условие...)
	{
		//...некоторые действия...
	}
}
```
Внутренний цикл вып. полностью при каждом вып. тела внешнего цикла.
Переменная-счетчик цикла (year), исп. во внутреннем цикле, явл. неопределенной вне области видимости внутреннего цикла.

**запомни!**
Цикл. содержащийся внутри другого цикла, называется *вложенным* (nested).
Вложенные циклы не могут "пересекаться"? 
т. е. приведенный ниже прим. некорректен:
```
do //начало цикла do..while
{
	for(...)      //начало цикла for
	{	
	} while(...) //конец цикла do.while
}                //конец цикла for
```

**запомни!**
Оператор `break` внутри вложенного цикла прекращает выполнение только этого вложенного цикла.
В фрагменте далее оператор `break` завершает работу цикла Б и возвращает упр. циклу А:
```
//Цикл for A
for(...некоторое условие...)
{
	//Цикл for Б
	for(...некоторое другое условие...)
	{
		//...некоторые действия...
		if (истинное условие)
		{
			break; //выход из цикла Б, но не из цикла А
		}
	}
}
```

В C# нет команды `break`, которая обеспечивала бы одновременный выход из обоих циклов. 
Вы должны исп. два оператора `break`, по одному для каждого цикла.

**технические подробности**
Это не настолько большое ограничение. 
На практике, сложную логику, внутри вложенных циклов, лучше инкапсулировать в виде функций. 
Выполнение оператора `return` в любом месте обеспечивает выход из функции, т. е. из всех циклов, 
какой бы не была глубина вложенности. 
Функции и оператор `return` будет рассматривать в гл. 7 "работа с коллекциями".

### операратор goto
Управление может быть передано в др. точку с пом. оператора безусловного перехода `goto`.
За этим оператором может следовать:
- метка;
- `case` в конструкции `switch`;
- ключевое слово `default`, обозначающее блок `default` в конструкции `switch`.

Два последних случая предназначены дял перехода от одного блока `case` к другому в конструкции `switch`.
прим.
```
//если условие истинно...
if (a>b)
{
	//упр. оператором goto передается коду, 
	//расположенному за меткой exitLabel
	goto exitLabel;
}
//некоторый программный код
exitLabel:
//управление передается в эту точку
```
Оператор `goto` непопулярен по причине, по которой он явл. очень мощным средством:
в силу его полной неструктурированности.
Отслеживание переходов в нетривиальных ситуациях, превышающих несколько строк кода - крайне неблагодраная задача. 
Это случай, когда говорят о "соплях" в программе.

**совет**
Вокруг прим. `goto` ведутся постоянные войны.
Доходит до критики того, что в нем есть этот оператор.
Но на самом деле в нем нет ничего ужасного. 
Его прим. след. избегать, если в этом нет крайней необходимости.
Я бы реккомендовал исп. `goto` только *изредка* для связи двух `case` в конструкции `swich`.
...
Не привыкайте исп. `goto`!