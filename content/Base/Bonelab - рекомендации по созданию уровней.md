202210031301
***
[[00 Bonelab]]
***
*ссылки*
[Best Practices for Level Creation](https://mod.io/g/bonelab/r/best-practices-for-level-creation)
***
## Гайд
Итак, вы получили SDK и импортировали модель уровня, которую вы взяли из своей любимой игры, с любовью созданную в программном обеспечении для 3D-моделирования. Вы настраиваете его в меру своих возможностей, помещаете в Bonelab и ... блин. Это выглядит ужасно. Вещи проваливаются сквозь землю. Он работает со скоростью 10 кадров в минуту. Что ты сделал не так?

Не бойся, друг, Лавовая Банда здесь, чтобы помочь тебе.

Прежде чем мы начнем: *это не практическое руководство*. В этом руководстве предполагается, что вы уже знакомы с основами Unity и, в идеале, с некоторыми элементарными элементами 3D-моделирования, а также с тем, как импортировать и использовать SDK. Вы должны знать основные термины разработки игр, такие как *rigidbody* и *mesh collider*. И я не собираюсь учить вас дизайну уровней. Это руководство предназначено для того, чтобы получить максимальную отдачу от вашей сцены визуально, добиться ее хорошей работы, а также для того, чтобы она была приятной для физики и виртуальной реальности. Я буду обновлять это руководство по мере добавления новых наших внутренних инструментов в SDK, но пока оно будет охватывать только то, что доступно по умолчанию в Unity 2021.
```
поиск гайдов rigidbody и mesh collider
```
***
## Colliders
Первое и самое важное, что вам нужно будет сделать после импорта или создания вашего уровня это настроить его. 
Для многих моддеров это будет означать установку *Mesh Collider* на каждую сетку и завершение работы. 
Пожалуйста, ради всего святого, *не делай этого*.  
- *Mesh Colliders* толщиной с бумагу, и при использовании в качестве основы они заставляют физические предметы и часто игрока проходить прямо сквозь них.  
- *Mesh Colliders* тяжелые. Они не только сложнее, чем необходимо с точки зрения геометрии, но и то, как Unity вычисляет физику, означает, что он выполняет дополнительную работу всякий раз, когда твердое тело находится внутри границ коллайдера с вогнутой сеткой.

### Как сделать collider в моей карте?
[[Unity - Collider]]
**используйте Primitive Colliders**
Лучший способ коллайдера сцены - сделать это с помощью примитивов: кубов, капсул и сфер. 
Это может быть утомительно и потребовать много работы, но оно того стоит. Это серьезная оптимизация производительности, которая даст вам гораздо больше контроля над материалами поверхности (о чем мы поговорим позже) и другими функциями, которые мы или другие моддеры можем реализовать в дальнейшем. Это также поможет вам устранить большинство физических ошибок, связанных с вогнутыми сетчатыми коллайдерами, таких как падение сквозь землю и физические взрывы.

**Do:**
- Разместите каждый *collider* на своем собственном *Game Object*. *Colliders* нельзя вращать, но *Game Object* можно! 
  Это также очень помогает в организации.  
- Сделайте небольшое перекрытие там, где встречаются *colliders*. Это помогает избежать попадания физических объектов сквозь швы.  
- Независимо от организации, сэкономьте немного времени, добавив *primitive collider* прямо на *game object with the mesh*: Unity попытается автоматически настроить размер *коллайдера* в соответствии с *mesh*. Затем вы можете скопировать и вставить этот *коллайдер* в дочерний игровой объект для организации или просто оставить его, если вы мазохист.

**Старайтесь избегать:**
- *Тонкие коллайдеры*. Тонкие коллайдеры (10 см) имеют высокую вероятность возникновения физических проблем, особенно при высокой скорости или низкой частоте кадров. Плоскости основания и стены должны быть толщиной *10-50 см*. Если игрок ударяет по нему со скоростью, например, по стене на трассе для картинга или по земле после сильного падения, он должен быть толще, в идеале на *1 метр*.
- *Масштабирование*. Используйте значения *Collider's Size* и *Center values*, чтобы получить форму. Масштабирование коллайдера с использованием *Transform values* может вызвать множество проблем, особенно с *grips* и другими *Marrow1 interactions*.  
- *Быть слишком точным*. Если вы бросаете 100 коллайдеров на объект, чтобы сделать его точным, коллайдер с вогнутой сеткой может быть в итоге более производительным (но все равно будет иметь проблемы с физикой).
- *Недостаточно точен*. Помните, что в виртуальной реальности это гораздо более очевидно, чем в играх с плоским экраном, когда что-то отрывается от земли или ваша рука натыкается на невидимый барьер. В разумных пределах старайтесь быть точными в соответствии со своим географическим положением. Просто подумайте, с какими вещами игрок будет или не будет тесно взаимодействовать.

**Когда использовать Mesh Colliders**

Но я понимаю: ваша сцена имеет сложную геометрию, которую нельзя просто аккуратно разбить на коробки и капсулы.
*Экономное использование сетчатых коллайдеров - это нормально*.
![[screenshot2022-10-02124243.webp|500]]
Эти два отдельных камня было бы неудобно создавать с помощью *Box Colliders*, но они являются отличными кандидатами для *convex Mesh Collider*.

Точность взаимодействия в VR означает, что люди с гораздо большей вероятностью заметят, когда ваши коллайдеры не соответствуют геометрии, но это не значит, что все должно быть точно. Для многих объектов использование *convex (выпуклый) Mesh Collider* может сэкономить вам много времени и усилий и быть достаточно близким. Используйте на свое усмотрение.

То же самое относится и к *concave (вогнутый) Mesh Colliders*; иногда стоит сэкономить время, чтобы просто нанести их на объект и на этом закончить. Разделение сеток вашей сцены, как упоминалось ранее, очень поможет в этом. Один объект в сцене, имеющий собственный *concave Mesh Collider*, имеет минимальное снижение производительности, поскольку его границы для вычисления физики будут намного меньше. Однако вам следует быть осторожным, если объект представляет собой нечто, во что игрок может врезаться на большой скорости, например, препятствие на трассе для картинга. 
**Чем быстрее физическое взаимодействие, тем больше вероятность того, что оно вызовет нежелательное поведение с concave Mesh**. 
То же самое относится и к тому, если игрок будет взаимодействовать с объектом с помощью собственного тонкого коллайдера, например, используя лом для скольжения вниз по зиплайну. *Тонкие коллайдеры имеют высокую вероятность прохождения друг сквозь друга*.

**Physic Materials**
Это менее известная особенность, но каждому коллайдеру можно придать его собственные уникальные физические свойства, такие как *упругость* и *трение*. Большинство коллайдеров будут в порядке, если им не будет предоставлен один: по умолчанию он будет соответствовать свойствам бетона. Но если вам нужна скользкая, упругая или липкая поверхность, вы можете изменить их здесь. Нам нравится использовать Умножение, а не усреднение, и мы используем реальные физические значения для различных материалов. Эти значения можно найти с помощью Google.

*Физические материалы* гораздо важнее для *физических объектов* чем *статичных*. 
Если вы не добавляете их ни к чему другому, по крайней мере, добавьте их в свой *props*.
![[screenshot2022-10-02124721.webp|500]]

Кстати говоря, вам могут понадобиться разные значения для ваших *динамических и статических объектов*. Это значения, которые мы используем для статического бетона (поскольку это фактические значения IRL), но они могут показаться довольно глупыми на динамическом бетонном блоке, для которого мы установили *Bounciness (упругость) 0,05*.
***
## Lighting
### Общие советы
- Не сходите с ума от значения интенсивности. 
  Для начала большинство источников света должны иметь интенсивность всего 1. 
  Используйте диапазон для регулировки снижения температуры сердцевины. В реальной жизни у света нет диапазона.
  *(range to adjust falloff of core hotness)*
- *Не используйте real-time lights.* **НИКОГДА**.
  Серьезно, они чрезвычайно тяжелые, и один или два будут уменьшать частоту кадров даже на ПК. 
  Один свет в реальном времени с тенями может быть использован только в Quest2. 
  Если необходимо, попробуйте смешанный свет или свет в реальном времени без теней. 
  Тем не менее, используйте их крайне экономно, а лучше вообще не используйте.  
- *Emissive maps* действительно пропускают свет в *lightmap*. 
  Обычно мы ставим значение *Emissive Multiplier* равным 5 для реальных источников света с картой излучения. 
  Это значение часто приводит к тому, что нам даже не нужно добавлять свет в сцену, всю работу сделает карта излучения.  
- *Точечные светильники немного испорчены в этой версии Unity*. 
  Возможно, вам придется по-настоящему подкрутить значения, чтобы они выглядели правильно при запекании. 
  Точечный светильник, который хорошо смотрится при интенсивности 2 и диапазоне 50, может нуждаться в интенсивности 40 и диапазоне 300, чтобы выглядеть одинаково при выпечке. 
  Это то, что есть.
- Старайтесь использовать *Area Lights* вместо *Point Lights*, когда это имеет смысл. 
  У вас гораздо больше контроля над ними.
  *Point Lights* выглядят безвкусно, если только источник не должен излучать всенаправленно.  
- *Hard Shadows* выглядят дергаными вне *Directional Lights* (и даже тогда tbh). 
  Используйте *Soft Shadows*, а для теней, которые вы хотите сделать четкими, просто используйте *Baked Shadow Radius*, например 0,1.  
- На вкладке *Environment* => *Lighting window* вы можете добавить *Skybox* и внести свой вклад в освещение. 
  Если ваша сцена проходит в закрытом помещении, убедитесь, что здесь не установлен *Skybox*, иначе это испортит запекание света. 
  В этом случае также установите для освещения окружающей среды значение `Color` и сделайте этот цвет черным. 
  В большинстве случаев для параметра `Environment Reflections` следует установить значение `Custom`.

### Probes
Многие люди забудут об этом шаге, но он имеет решающее значение. 
Часто вы будете делать все остальное правильно, но ваша сцена все равно будет выглядеть ужасно, и вы не будете знать почему. 
Вот почему.

**Reflection Probes**

Как только геометрия вашей сцены будет хотя бы приблизительно завершена, вам нужно будет добавить *reflection probes*. 
Этот шаг абсолютно обязателен для того, чтобы сцена выглядела хорошо.

Для каждой комнаты или зоны потребуется свой собственный probe. 
Установите probe примерно на высоте игрока и отрегулируйте границы до тех пор, пока они не окажутся немного за пределами стен или краев области. 
Нам нравится проверять Box Projection. 
Reflection probes можно выпекать отдельно, независимо от формы для выпечки.
Но лампы для выпечки автоматически запекают все датчики отражения в сцене.
![[screenshot2022-10-02134308.webp|500]]

Такая карта, как de_dust, хорошо подходит для тех же методов зондирования, которые вы используете в помещении, 
но для большой широко открытой карты, такой как Тоскана или остров Уху, 
вам нужно вернуться на эту вкладку `Environmental Reflections` и изменить отображение окружающей среды обратно на `Skybox`.
Ставте *Probes* помещения внутри зданий и вокруг них, но затем выделите несколько гораздо больших площадей для наружного использования.

**Light Probes**
Так же важны, как и *Reflection Probes*. 
Динамические объекты, такие как реквизит, NPC и даже игрок, не будут адаптироваться к освещению без них. 
Ваш рабочий процесс для исследования сцены зависит от вас, просто убедитесь, что они у вас есть. 
Имейте более высокую плотность зондирования там, где, скорее всего, находится игрок, и менее плотную в местах, куда они вряд ли пойдут, например, у потолка. 
Но они все равно должны быть везде, кроме как за пределами карты или внутри стен.

### Baking Lights

Спасибо, Dall-E, но это не совсем то, что я имел в виду.

Встроенная система lightbake от Unity на самом деле довольно надежна. 
Особенно с новым процессором GPU bake, вы можете создать целую сцену за считанные минуты. 
Убедитесь, что вы создаете UV-изображения lightmaps при моделировании или при импорте моделей, установите флажок `Generate Lightmap UVs` в настройках импорта модели. 
Кроме того, в выпечку будут включены только Static items или items, для которых установлен флажок `Contribute GI` в разделе Static.

Для начала, вот несколько начальных настроек, с помощью которых я буду готовить большинство сцен:  
Выключите *Realtime Global Illumination*.  
Установите режим освещения на *Baked Indirect*.
![[screenshot2022-10-02131954.webp|500]]

### Fog (туман)
...
***
## Physics
Ладно, вот тут-то все и становится интересным. 
Вы можете пренебречь советом здесь, поскольку он относится к потребностям вашего конкретного уровня. 
Мы не являемся конечными экспертами PhysX. 
Но есть некоторые действительно распространенные проблемы и ошибки, с которыми сталкиваются люди, когда они на самом деле не знают, что делают.

### Общие советы
[[Unity - RigidBody]]
- Будьте реалистичны с весом *Rigidbody*. 
  Пистолет или меч могут подойти при весе по умолчанию 1 кг, но деревянный ящик - нет. 
  Полезно посмотреть точные веса в Google, чтобы оставаться последовательным.  
- Не масштабируйте *Rigidbodies*. 
  Если необходимо, делайте это равномерно; не масштабируйте по-разному на разных осях. 
  И ради всего святого, не используйте обратную шкалу.  
- Избегайте анимированных объектов и движущихся кинематических жестких тел. 
  Эти вещи обладают бесконечной силой, которая не только неизбежно приведет к массовым ошибкам в физике, но и просто не очень выгодна для *Marrow*. 
  Вместо этого используйте *Configurable Joints* или *Spline Joints*.  
- *Hinge Joint* - это просто *Configurable Joint* с меньшим количеством настроек. 
  Хотя учиться с ними может быть полезно, в конце концов вам захочется изучить *full Configurable Joint*.  
- Не оставляйте объекты, похожие на физичные, статичными в вашей сцене. 
  Если вы можете перемещать его в реальной жизни, у него должно быть *rididbody*.

### Impacts
*ImpactSFX* и *Impact Properties*. 
Это еще не включено в Marrow SDK. 
Это будет обновлено, если будет добавлено. 
Это не гарантия того, что это произойдет.

### Configurable Joints
*Configurable Joints* - это самый мощный инструмент, который у вас будет как у моддера. 
Они также являются кошмаром. 
Документация ужасна, и, похоже, даже люди, которые ее создавали, не до конца понимают, что делают все функции. 
Поэтому я не собираюсь учить вас здесь настраиваемым соединениям, сначала вам нужно самим изучить основы. 
Но вот некоторые из вещей, которые я узнал, пытаясь создавать общие вещи.

- *Spring* используется в двух разных контекстах и в каждом из них выполняет совершенно разные функции. Просто имейте это в виду.
- Силы выражаются в ньютонах. 
  Для большинства из вас это мало что значит. 
  Приблизительный, 10 ньютонов - это немного, 100 ньютонов - приличное количество, 1000 ньютонов - это мощно, 10000+ - это уровни силы машины.
- При устранении неполадок может быть полезно добавить тонну нулей (к одному значению за раз). 
  Он может делать нелепые вещи, но это поможет вам понять функции.
- Если что-то движется или останавливается слишком долго, используйте очень большие *Spring/Damper forces*, а затем ограничьте его максимальное усилие. 
  Это гарантирует, что сустав всегда использует всю свою мощность для достижения цели.
- Ось X имеет больше элементов управления, чем Y и Z. 
  Если ваш объект будет двигаться только вдоль одной оси, это может помочь заставить его быть X. 
  Вы можете сделать это, установив 'Ось' равной 1 для той оси, по которой должен двигаться сустав. 
  Итак, если у вас есть дверь, которая вращается по оси Y, установите Axis: Y = 1, и теперь все настройки соединения будут обрабатывать вашу ось Y как X. 
  Таким образом, вы можете использовать ограничения X, приводы X и т. д. для вращения вокруг оси Y. 
  Немного сбивает с толку, но вы в этом разберетесь. 
  Просто убедитесь, что только одно значение равно 1, иначе вам придется начать изучать кватернионы.
- В Marrow встроено максимальное усилие разрыва, но оно все равно может помочь придать большинству суставов усилие разрыва (даже если оно очень высокое), чтобы избежать физических ошибок. Теперь, когда в игре появились чертовски сильные аватары, это особенно важно.
  4000-6000 - это сложная задача для стандартного игрока.
- Постоянно движущиеся предметы могут быть сложными, особенно если они не предназначены для создания большого усилия. 
  Даже если вы зададите *Target Angular Velocity*, шарнир, к сожалению, все равно будет пытаться перейти к вашему *Target Rotation* (вероятно 0,0,0). 
  Может помочь установка низкого *Spring force* относительно вашего *Damper* и высокое *Max Force*. 
  250-килограммовое вращающееся препятствие *Timber Roller* в *Fantasy Arena* имеет *Spring force* всего 500 с *Damper* 1000000 и *Max Force* 50000 при *Target Anglular Velocity* 1,35.
  ***
## Разное
### NavMesh
Испеките один. 
Установите Agent Height равной 1,85, Radius - 0,25. 
Наш ИИ теперь может ходить по наклонным поверхностям, но не очень хорошо. 
Я бы не стал подниматься выше 30 град. 
Вы можете добавить препятствие NavMesh к динамическим объектам, которым вы хотите, чтобы враги их избегали, но имейте в виду, что они довольно тяжелые для CPU.

### Occlusion
Испеките его.

На самом деле это еще не все. 
Встроенная окклюзия Unity довольно потерта, но мы работаем с тем, что у нас есть. 
*Occlusion* - еще одна важная причина, по которой рекомендуется немного разбить сетку уровней. 
Если это один гигантский фрагмент, то все изображение будет отображаться сразу, независимо от того, куда вы смотрите. 
Разбиение позволяет объектам, находящимся вне поля зрения игрока, прекратить рендеринг. 
*Occlusion* - это баланс между сохранением графического процессора и загрузкой процессора. 
Если настройки вашего окклюдера слишком точны, то у вашего процессора возникнут проблемы, особенно в Quest2. 
Для начала рекомендуется установить наименьшее значение окклюдера, равное 2, а при крайней необходимости - всего 1. 
Самое маленькое отверстие должно быть около 0,25 дюйма. 
Если у вас отверстия меньшего размера, подумайте о том, чтобы сделать окружающие их объекты non-Occluder Static. 
Ничто не должно быть Окклюдером, но все статические объекты будут по умолчанию. 
Мы обнаружили, что очень длинные объекты создают ненужную нагрузку на CPU, в то же время мало помогая GPU. 
Поэтому установите, чтобы труба, проходящая по всей длине вашего коридора, была статичной без окклюдера.

Вы могли бы сделать гораздо больше, но это самое главное.

### Производительность

У Meta есть несколько рекомендаций по оптимизации виртуальной реальности здесь.

Кроме того, прозрачность является большой проблемой на платформах Android. 
Это отстой, но избегайте таких вещей, как окна и надписи, насколько это возможно, если вы хотите, чтобы ваш уровень можно было играть в Quest2. 
Чем больше места на экране они занимают, тем больше падает производительность. 
Это относится к любому прозрачному материалу или шейдеру.

### Некоторые принципы проектирования

Я сказал, что не буду учить вас дизайну уровней, но есть некоторые вещи, которые я хотел бы донести до вас.  
  
Помните, что Marrow1 - это физический движок и движок взаимодействия. 
Наша философия - это свобода и отсутствие неправильных ответов. 
Это означает, что такие вещи, как невидимые стены, должны быть запрещены. 
Если вы не хотите, чтобы ваш игрок испортил вашу карту, спросите себя, почему. 
Было бы забавно перепрыгнуть через эту стену вместо того, чтобы идти по переулку? 
Разве это не здорово - разбить окно и залезть внутрь, а не быть вынужденным искать ключ? 
Как можно чаще позволяйте игроку делать то, что он хочет.  
  
Это действительно затрудняет определение границ уровней. 
Это важная причина, по которой мы устанавливаем наши уровни канонически внутри камер с голографическими стенами. 
Вы не можете просто поставить забор и сказать, что игрок не может перелезть через него. 
У вас должны быть физически обоснованные причины, по которым игрок не может идти туда, куда он хочет. 
Это большая проблема проектирования, но она крайне важна для построения в чисто физической среде.
***
На данный момент это все. 
Я собираюсь добавить больше по мере того, как основные проблемы и ошибки людей становятся все более очевидными, а также по мере добавления новых функций в Marrow SDK. 
Не стесняйтесь задавать мне вопросы на сервере Lava Gang Discord, канал #levels: https://discord.gg/dhDFWP3Y

И привет, добро пожаловать домой. 
С Lava Gang все возможно.